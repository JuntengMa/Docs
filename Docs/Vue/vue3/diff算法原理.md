# [vue3 Diff算法](https://www.bilibili.com/video/BV1Xp4y1V7TP/?spm_id_from=333.788.recommend_more_video.2&vd_source=45e085bf2f0364e8005f1ace4350ecc0)

#### 1、 diff算法是干什么的

> Vue 的 diff 算法是用于比较 Virtual DOM（虚拟 DOM）树的变化，并找出最小量的更新操作，从而将新的 Virtual DOM 树更新到实际 DOM 上，以提高页面渲染效率和性能。

#### 2、为什么需要diff算法

> 因为在开发过程中，直接操作DOM元素是一种非常耗性能的操作，涉及到浏览器的重排和回流，如果每次变化都触发重新渲染整个页面会导致性能问题，降低用户体验

#### 3、diff算法做了些什么

> 通过对比新旧vnode 的区别；
>
> - **找出两者最小化差异：** Diff 算法会对比两棵树的结构，找出它们之间的差异。这意味着算法会检测哪些节点被添加、删除或修改。
> - **最小化更新：**找出差异之后，diff算法会尽可能的减少dom操作，将多个修改合并为同一个更新操作。
> - **提高性能：**通过虚拟dom减少真实dom操作，进而减少浏览器重绘回流，提升网页性能
> - **保持视图与状态同步：**当状态被修改之后，diff算法通过对比计算出dom最小修改点并修改对应dom元素，及时更新页面内容

#### 4、diff算法原理

> Vue 3中的diff算法相较于Vue 2做了许多优化，以提高虚拟DOM的更新效率和性能。以下是Vue 3中diff算法的一些关键优化点和使用的算法：
>
> 1. **PatchFlag的使用**：
>    - Vue 3引入了PatchFlag，这是一种标记系统，用于标记不同类型的节点。
>    - 这些标记指示diff算法在处理特定节点时可以采取的优化措施。
>    - 在编译阶段添加到虚拟节点（VNode）中的。它用于标记节点的不同属性，以便在diff算法执行时能够快速识别和应用特定的优化策略。
>    - 例如，如果一个节点被标记为只有文本内容是动态的，那么在diff过程中，算法可以跳过对这个节点的其他属性的检查。
> 2. **静态提升（Static Hoisting）**：
>    - 在Vue 3中，编译器会识别模板中的静态内容（即不会改变的内容），并在diff过程中将这些静态节点提升到更高的层级。
>    - 这意味着静态节点只会被创建一次，并在后续的更新中复用，减少了不必要的DOM操作。
> 3. **双端比较（Two-End Comparison）**： 
>    - 在处理同层级的多个子节点时，Vue 3会从头部和尾部同时开始比较新旧两个虚拟DOM树。
>    - 这样可以快速识别并处理那些没有变化的节点，减少了比较的次数。
> 4. **最长递增子序列（Longest Increasing Subsequence）**：
>    - Vue 3在处理列表更新时，使用了<font color="red">最长递增子序列算法</font>来减少节点的移动。
>    - 这个算法可以找到两个数组之间共有的最长递增子序列，从而确定节点移动的最小数量。
>    - 这有助于减少DOM操作，因为移动DOM元素是比较昂贵的操作。
> 5. **keyToNewIndexMap的使用**： 在处理带有key的列表时，Vue 3会创建一个key到新索引的映射（keyToNewIndexMap）。这个映射帮助算法快速找到新旧节点之间的对应关系，从而进行有效的更新和复用。
> 6. **事件侦听器缓存（cacheHandlers）**： Vue 3还引入了事件侦听器缓存机制，允许组件在更新时保留原有的事件侦听器，而不是重新创建。这减少了不必要的事件侦听器的创建和销毁，提高了性能。
> 7. **更细粒度的虚拟节点（VNode）**： Vue 3中的虚拟节点更加细粒度，允许对组件的更小部分进行更新，而不是整个组件。这减少了不必要的重新渲染，提高了性能。
> 8. **优化的源码结构**： Vue 3的源码结构更加模块化和可维护，使得diff算法的实现更加清晰和高效。
>
> 这些优化措施共同作用，使得Vue 3在处理大型和复杂的应用时，能够更加高效地更新虚拟DOM，从而提升整体的性能。

#### 5、vue中ast语法树和vnode有什么异同，为什么不直接使用ast做diff运算

> **AST（Abstract Syntax Tree）**：
>
> - AST是源代码的<font color="red">抽象语法结构的树状表现形式</font>，它用于表示代码的结构，但不包含实际的代码内容。
> - 在Vue中，AST主要用于编译阶段，将`.vue`文件中的模板编译成JavaScript代码，特别是生成render函数。
> - AST节点包含了模板的结构信息，如标签名、属性、子节点等，但不包含实际的DOM操作信息。
> - AST是一次性使用的结构，编译完成后通常不会被再次使用。
>
> **VNode（Virtual Node）**：
>
> - VNode是Vue虚拟DOM的一部分，它是真实DOM的抽象，包含了渲染到页面上所需的所有信息。
> - VNode用于Vue的响应式系统中，用于追踪状态变化并触发DOM的更新。
> - VNode包含了更丰富的信息，如key、selctor、data、children等，这些都是用于diff算法和实际DOM操作的关键信息。
> - VNode在组件的每次渲染过程中都会被创建，并用于计算新旧节点之间的差异。
>
> **异同点**：
>
> - 相同点：AST和VNode都是树状结构，用于表示代码或DOM的结构。
> - 不同点：AST主要用于编译阶段，而VNode用于运行时的渲染和更新过程。AST是一次性的，VNode则是响应式的，会随着状态变化而更新。
>
> **为什么不直接使用AST做diff运算**：
>
> - AST虽然能够表示模板的结构，但它不包含用于实际DOM操作的信息，如key、事件监听器等，这些都是在运行时才需要的。
> - AST在编译阶段后通常就不再使用了，而diff运算是在运行时进行的，需要一个能够反映当前状态并支持动态更新的数据结构。
> - VNode结构更加精简，专门为虚拟DOM的diff算法和实际DOM操作优化，而AST则包含了更多编译时的元信息，不适合直接用于diff运算。
>
> 总结来说，AST和VNode在Vue中分别用于不同的阶段，AST用于编译模板生成render函数，而VNode用于运行时的渲染和更新。直接使用AST进行diff运算不现实，因为它缺乏运行时所需的信息和优化。

#### 6、最长递增子序列算法

> 最长递增子序列问题：
>
> 给定一个未排序的整数数组，找到一个最长的子序列（不一定连续），使得子序列中的所有元素都严格递增。这个子序列的长度即为最长递增序列长度。
>
> 在Vue 3的虚拟DOM diff算法中，最长递增子序列用于处理 keyed 列表的更新。每个节点（或节点组）都有一个唯一的key，通过这个key，算法可以找到两个数组之间共有的最长递增子序列，从而确定节点移动的最小数量。
>
> 以下是最长递增子序列算法的基本概念和步骤，以及一个简化的例子来帮助理解：
>
> # 算法步骤：
>
> 1. **初始化**：创建两个数组，`map`和`tails`，`map`用于存储每个元素的索引位置，`tails`用于存储当前找到的最长递增子序列的尾部元素。
> 2. **遍历**：遍历新旧两个数组，对于每个元素，执行以下操作：
>    - 在`map`中查找最后一个小于当前元素的所有元素的索引（即找到当前元素在递增子序列中的位置）。
>    - 更新`tails`数组，如果当前元素大于`tails`数组的最后一个元素，说明找到了一个更长的递增子序列，更新`tails`的最后一个元素为当前元素。
>    - 如果当前元素小于`tails`数组的最后一个元素，说明当前元素可以接在某个递增子序列的尾部，更新`tails`数组中对应位置的元素。
> 3. **结果**：遍历完成后，`tails`数组的最后一个元素即为最长递增子序列的长度。
>
> # 例子：
>
> 假设我们有两个数组，旧数组`A`和新数组`B`，它们分别代表更新前后的列表。
>
> ```
> A = [1, 3, 5, 7, 9]
> B = [1, 3, 4, 7, 9]
> ```
>
> 我们想要找到这两个数组之间的最长递增子序列。
>
> 1. 初始化`map`和`tails`数组。
>
> ```
> map = [0, 1, 2, 3, 4]  # 初始时，每个元素的索引位置就是它在原数组中的位置。
> tails = [1, 3, 5, 7, 9]  # 初始时，每个元素都是一个递增子序列的尾部。
> ```
>
> 1. 遍历新数组`B`，对于每个元素，找到`map`中最后一个小于它的元素的索引，并更新`tails`。
>
> ```
> 遍历到1，map[1] = 0，tails = [1, 3, 5, 7, 9]（1已经在tails中，不需要更新）。
> 
> 遍历到3，map[3] = 1，tails = [1, 3, 5, 7, 9]（3已经在tails中，不需要更新）。
> 
> 遍历到4，map[4] = 2（因为5是最后一个小于4的元素），tails = [1, 3, 4, 7, 9]（4接在了递增子序列[1, 3]的尾部）。
> 
> 遍历到7，map[7] = 3，tails = [1, 3, 4, 7, 9]（7已经在tails中，不需要更新）。
> 
> 遍历到9，map[9] = 4（因为7是最后一个小于9的元素），tails = [1, 3, 4, 7, 9]（9已经在tails中，不需要更新）。
> ```
>
> 1. 最终，最长递增子序列的长度为`tails`数组的最后一个元素，即`tails[4]`，结果是9。
>
> 通过这个算法，Vue 3可以高效地确定在更新列表时哪些元素可以复用，哪些元素需要移动，从而减少DOM操作，提高性能。
>
> 为了更直观地理解这个过程，可以想象每个元素都在尝试找到一个位置，使得它能够保持在递增的顺序中，同时尽可能地延长这个递增序列。这个算法的核心思想是，通过维护一个递增序列的尾部元素列表，我们可以在O(n)的时间复杂度内找到最长递增子序列。



7、最长递增子树序列

Vue 3的diff算法中，最长递增子序列（Longest Increasing Subsequence，LIS）是一种用于比较两个数组之间差异的算法。在Vue 3中，LIS算法用于帮助确定在更新DOM时哪些元素需要进行移动，以最小化DOM操作的次数，从而提高性能。

LIS算法的原理是找到一个给定数组中最长的递增子序列。这意味着在原始数组中找到一个子序列，其中的元素按顺序递增，但不一定是连续的。在Vue 3的diff算法中，LIS算法用于确定在更新数组时哪些元素保持不变，哪些需要移动位置，以便尽可能地减少DOM操作。

LIS算法的工作原理是通过动态规划来实现。它使用一个辅助数组来存储以每个元素结尾的最长递增子序列的长度。通过遍历数组并不断更新这个辅助数组，最终可以找到整个数组的最长递增子序列的长度。

在Vue 3中，LIS算法的工作是为了优化DOM更新，通过减少元素的移动操作来提高性能。通过识别最长递增子序列，Vue 3可以更智能地决定哪些元素需要移动，哪些可以保持不变，从而减少整体的DOM操作次数。

总的来说，LIS算法在Vue 3的diff算法中起到了优化DOM更新的作用，通过找到最长递增子序列，帮助减少了不必要的DOM操作，提高了性能和效率。

--------------------------------

#### 参考

1. [vue3.0 diff算法详解(超详细) - 知乎](https://zhuanlan.zhihu.com/p/150103393)
   - 详细介绍了Vue 3.0 beta版本diff算法的源码细节和优化点。
2. [Vue3.0时代你必须了解的：diff算法原理和优化 - 掘金](https://juejin.cn/post/6883788411590279176)
   - 分析了Vue 3.0的diff算法原理，包括virtual dom的概念、diff算法的优化措施，以及Vue 3.0中diff算法的具体实现和优化。
3. [Vue3 diff算法图解分析 - 知乎](https://zhuanlan.zhihu.com/p/459134214)
   - 通过图解的方式分析Vue 3的diff算法，帮助理解diff的主要过程和核心逻辑。
4. [一文搞懂 Vue3 的 diff 算法（3.3.8 版本源码](https://xn-- vue3  diff (3-zr68amy10aolmf2ihp5c5w6cv04a.3.xn--8 -8j1im29amqg6wm/)） - 知乎
   - 对比Vue 2和Vue 3的diff算法，并详细解析Vue 3中的优化。
5. [Vue3 Diff核心算法 - 最长递增子序列 - 个人文章 ... - SegmentFault 思否](https://segmentfault.com/a/1190000039838442)
   - 专注于解析Vue 3 Dom Diff中的核心算法：最长递增子序列，并对diff细节进行了深入的探讨。
