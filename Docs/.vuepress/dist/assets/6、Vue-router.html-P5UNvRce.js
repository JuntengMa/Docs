import{_ as a,o as n,c as s,e as t}from"./app-iph3vjA0.js";const e={},o=t(`<h1 id="vue-router" tabindex="-1"><a class="header-anchor" href="#vue-router" aria-hidden="true">#</a> Vue router</h1><p>Vue-router通过使用浏览器history.pushState方法可以改变地址栏的路径而不用刷新页面， 所以这使得我们只需要在第一次进入页面的时候去请求一次html，后续的页面呈现则交由js来控制，根据不同url路径来加载不同的js模块。 (路由懒加载)</p><h4 id="_1、路由懒加载原理" tabindex="-1"><a class="header-anchor" href="#_1、路由懒加载原理" aria-hidden="true">#</a> 1、路由懒加载原理</h4><blockquote><p>当打包构建应用时，假如不做代码分割，JavaScript 包会变得非常大，影响页面加载。</p><p>所以我们需要把不同路由对应页面组件进行代码分割，当路由访问的时候再加载对应组件;</p></blockquote><h4 id="_2、window-histiry" tabindex="-1"><a class="header-anchor" href="#_2、window-histiry" aria-hidden="true">#</a> 2、window.histiry</h4><p>https://blog.csdn.net/vipshop_fin_dev/article/details/108043500</p><p>https://juejin.cn/post/6948746074504986655</p><h4 id="_3、hash模式和history模式区别" tabindex="-1"><a class="header-anchor" href="#_3、hash模式和history模式区别" aria-hidden="true">#</a> 3、hash模式和History模式区别</h4><h5 id="history和hash的差异主要有以下点" tabindex="-1"><a class="header-anchor" href="#history和hash的差异主要有以下点" aria-hidden="true">#</a> history和hash的差异主要有以下点：</h5><ul><li>history和hash都是利用浏览器的<code>pushState（）、replaceState （） </code>实现前端路由，通过这两个方法改变url ， 页面不会刷新 <ul><li>history是利用浏览历史记录栈的API实现</li><li>hash是监听location对象hash值变化事件来实现</li></ul></li><li>history的url没有’#&#39;号，hash反之</li><li>history修改的url可以是同域的任意url，hash是同文档的url</li><li>相同的url，history会触发添加到浏览器历史记录栈中，hash不会触发。</li></ul><h5 id="history和hash的优点和缺点" tabindex="-1"><a class="header-anchor" href="#history和hash的优点和缺点" aria-hidden="true">#</a> history和hash的优点和缺点：</h5><ul><li>history比hash的url美观（没有’#&#39;号）</li><li>history修改的url可以是同域的任意url，hash则只能是同文档的url</li><li>history模式往往需要后端支持，如果后端nginx没有覆盖路由地址，就会返回404，hash因为是同文档的url，即使后端没有覆盖路由地址，也不会返回404</li><li>hash模式下，如果把url作为参数传后端，那么后端会直接从’#‘号截断，只处理’#&#39;号前的url，因此会存在#后的参数内容丢失的问题，不过这个问题hash模式下也有解决的方法。</li></ul><h4 id="_4、history模式为什么需要后端支持" tabindex="-1"><a class="header-anchor" href="#_4、history模式为什么需要后端支持" aria-hidden="true">#</a> 4、history模式为什么需要后端支持</h4><blockquote><p>假设应用地址为<code>abc.com</code>，服务端不加额外的配置。当通过<code>abc.com</code>来访问时，是没有问题的，可以正常加载到html文件，之后通过route-link或者router.api来跳转也不会有问题，因为之后都不会刷新页面请求html，只是通过<code>history.pushState</code>或者<code>history.replaceState</code>来改变history记录，修改地址栏地址而已；</p><p>但是如果是直接访问子路由<code>abc.com/test</code>时就会有问题，<code>/test</code>是子路由名，但是服务器中并不存在该目录，就无法索引到html文件，此种情况下就会出现404，所以不管是访问什么路径，都应该加载根目录的html文件，因为<code>/xxx/yyy</code>对我们应用来讲是子路由路径而已。</p></blockquote><h4 id="_5、全局路由导航守卫" tabindex="-1"><a class="header-anchor" href="#_5、全局路由导航守卫" aria-hidden="true">#</a> 5、全局路由导航守卫</h4><p>demo:</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>router<span class="token punctuation">.</span><span class="token function">beforeEach</span><span class="token punctuation">(</span><span class="token parameter">from <span class="token punctuation">,</span> to <span class="token punctuation">,</span>next</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>简单来说就是路由跳转过程中的一些钩子函数，这个过程分 前、中、后三个小过程，每个过程我们都可以做一些操作</p><h6 id="beforeeach-to-from-next" tabindex="-1"><a class="header-anchor" href="#beforeeach-to-from-next" aria-hidden="true">#</a> beforeEach(to,from,next):</h6><blockquote><p>在路由跳转前触发，参数包括to,from,next（参数会单独介绍）三个，这个钩子作用主要是用于==登录验证==，也就是路由还没跳转提前告知，以免跳转了再通知就为时已晚。</p></blockquote><h6 id="beforeresolve-to-from-next" tabindex="-1"><a class="header-anchor" href="#beforeresolve-to-from-next" aria-hidden="true">#</a> beforeResolve(to,from,next):</h6><blockquote><p>这个钩子和beforeEach类似，也是路由跳转前触发，参数也是to,from,next三个，和beforeEach区别官方解释为：</p><p>区别是在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用。</p><p>即在 beforeEach 和 组件内beforeRouteEnter 之后，afterEach之前调用。</p><p>流程： <code>beforeEach ---&gt; 组件内beforeRouteEnter ----&gt; beforeResolve —-&gt;afterEach</code></p></blockquote><h6 id="aftereach-to-from" tabindex="-1"><a class="header-anchor" href="#aftereach-to-from" aria-hidden="true">#</a> afterEach(to,from):</h6><blockquote><p>和beforeEach相反，他是在<strong>路由跳转完成后</strong>触发，参数包括to,from没有了next（参数会单独介绍）,他发生在beforeEach和beforeResolve之后，beforeRouteEnter（组件内守卫，后讲）之前。</p><p>流程： <code>beforeEach || beforeResolve —-&gt; afterEach ----&gt; beforeRouteEnter</code></p></blockquote><h6 id="组件内守卫" tabindex="-1"><a class="header-anchor" href="#组件内守卫" aria-hidden="true">#</a> 组件内守卫:</h6><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>	<span class="token function">beforeRouteEnter</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> from<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;进入该路由时执行 &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span><span class="token punctuation">,</span>
		<span class="token function">beforeRouteUpdate</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> from<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;该路由参数更新时执行 &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span><span class="token punctuation">,</span>
		<span class="token function">beforeRouteLeave</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> from<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;离开该路由时执行 &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,26),c=[o];function p(i,r){return n(),s("div",null,c)}const l=a(e,[["render",p],["__file","6、Vue-router.html.vue"]]);export{l as default};
