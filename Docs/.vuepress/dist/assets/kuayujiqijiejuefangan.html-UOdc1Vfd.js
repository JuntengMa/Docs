import{_ as s,r as i,o as c,c as t,a as d,b as e,d as a,f as r,e as o}from"./app-iph3vjA0.js";const l={},p=o('<h4 id="_1、什么是跨域" tabindex="-1"><a class="header-anchor" href="#_1、什么是跨域" aria-hidden="true">#</a> 1、什么是跨域？</h4><p>跨域简单来说就是浏览器<code>禁止加载非同源情况下的脚本</code>。浏览器的同源策略是为了保护用户的隐私安全，如果没有同源策略，很容易遭受网络攻击。</p><h4 id="_2、跨域策略限制的内容" tabindex="-1"><a class="header-anchor" href="#_2、跨域策略限制的内容" aria-hidden="true">#</a> 2、跨域策略限制的内容</h4><ul><li>Cookie、LocalStorage、IndexedDB 等存储性内容</li><li>DOM 节点</li><li>AJAX Fetch 请求</li></ul><h4 id="_3、可以跨域加载资源的标签" tabindex="-1"><a class="header-anchor" href="#_3、可以跨域加载资源的标签" aria-hidden="true">#</a> 3、可以跨域加载资源的标签：</h4><ol><li><code>&lt;img src=&#39;&#39; /&gt;</code></li><li><code>&lt;a href=&#39;&#39;&gt;&lt;/a&gt;</code></li><li><code>&lt;script src=&#39;&#39;&gt;&lt;/script&gt;</code></li><li><code>&lt;form url=&#39;&#39;/&gt;</code></li><li><code>&lt;iframe url=&#39;&#39;/&gt;</code></li></ol><h4 id="_4、解决跨域的方法" tabindex="-1"><a class="header-anchor" href="#_4、解决跨域的方法" aria-hidden="true">#</a> 4、解决跨域的方法</h4><blockquote><p>1、交给后端，让他想办法，不搞打死（修改请求头 、 配置服务器白名单等）</p><p>2、Nginx</p><p>3、CORS</p></blockquote>',8),h={id:"_5、cors",tabindex:"-1"},u=e("a",{class:"header-anchor",href:"#_5、cors","aria-hidden":"true"},"#",-1),m={href:"https://juejin.cn/post/6844903859068862472#heading-2",target:"_blank",rel:"noopener noreferrer"},g=o(`<blockquote><p>CORS 是==跨域资源共享（Cross-origin resource sharing）==，只要服务端实现了 CORS，就可以实现跨域资源共享；</p><p>服务端通过 Access-Control-Allow-Origin 属性来实现跨域，该字段表示哪些域名可以访问资源，如果是<code>*</code>就表示所有的域名都可以访问该资源。</p><p>它允许浏览器向跨源服务器发出 XMLHttpRequest、Fetch 请求，从而克服了 AJAX 只能同源使用的限制。</p><p>CORS 中，我们将请求分为<code>简单请求</code>和<code>非简单请求</code>，因为浏览器对于这两种请求的处理方式不同。</p></blockquote><h4 id="_6、怎么区分简单请求和非简单请求" tabindex="-1"><a class="header-anchor" href="#_6、怎么区分简单请求和非简单请求" aria-hidden="true">#</a> 6、怎么区分简单请求和非简单请求？</h4><p>浏览器将 CORS 请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。只要同时满足以下两大条件，就属于简单请求。凡是不同时满足上面两个条件，就属于非简单请求。</p><p>（1) 请求方法是以下三种方法之一：</p><blockquote><ul><li>HEAD</li><li>GET</li><li>POST</li></ul></blockquote><p>（2）HTTP 的头信息 Request Headers 不超出以下几种字段：</p><blockquote><ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Last-Event-ID</li><li>Content-Type：只限于三个值 application/x-www-form-urlencoded、multipart/form-data、text/plain</li></ul></blockquote><h4 id="_7、简单请求" tabindex="-1"><a class="header-anchor" href="#_7、简单请求" aria-hidden="true">#</a> 7、简单请求</h4><ul><li>对于简单请求，浏览器直接发出<code>CORS</code>请求，具体来说，就是在头信息之中，增加一个<code>Origin</code>字段。</li></ul><blockquote><p>当客户端发出简单跨域请求时，会在请求头中<strong>自动</strong>添加<code>origin</code>字段，表示本次请求来自哪个源（协议 + 域名 + 端口）</p><p>服务端根据这个字段看是否允许此次请求。</p><p>如果 origin 指定的源，不在服务器允许的范围内，服务器会返回一个正常的 http 响应，浏览器发现响应头中没有<code>Access-Control-Allow-Origin</code>字段，就会拦截该响应并报跨域的错误。</p></blockquote><p><img src="https://raw.githubusercontent.com/tengyuanOasis/image/master/image/202206071629606.png" alt="image-20220607162645420"></p><ul><li>如果 origin 指定的源，在允许的范围内，请求的响应头会返回以下几个字段，都以<code>Access-Control-</code>开头：</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 表示服务端允许访问该资源的源，为*表示允许所有源访问 ，👉👉👉必须传👈👈👈</span>
Access-Control-Allow-Origin: http://api.bob.com

<span class="token comment"># 表示服务端允许请求携带cookie , 如果需要携带cookie的话，浏览器端也要进行设置，设置请求的withCredentials属性为true，这样才能成功在请求中传输cookie。👉👉👉可选👈👈👈</span>
Access-Control-Allow-Credentials: <span class="token boolean">true</span>

<span class="token comment"># 表示指定XHR请求可通过getResponseHeader()获取到的首部响应字段。👉👉👉可选👈👈👈</span>
Access-Control-Expose-Headers: FooBar
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h6 id="request-headers" tabindex="-1"><a class="header-anchor" href="#request-headers" aria-hidden="true">#</a> Request Headers:</h6><img src="https://raw.githubusercontent.com/tengyuanOasis/image/master/202202172003384.png" alt="image-20220217200303313" style="zoom:80%;float:left;"><h6 id="response-headers" tabindex="-1"><a class="header-anchor" href="#response-headers" aria-hidden="true">#</a> Response Headers</h6><img src="https://raw.githubusercontent.com/tengyuanOasis/image/master/202202172008048.png" alt="image-20220217200810007" style="zoom:80%;float:left;"><h4 id="_8、怎么配置-简单请求-cors" tabindex="-1"><a class="header-anchor" href="#_8、怎么配置-简单请求-cors" aria-hidden="true">#</a> 8、怎么配置 简单请求 CORS</h4><p>==开启 CORS 关键在于客户端和服务端相互配合==</p><p><code>CORS</code>请求<strong>默认不发送</strong><code>Cookie</code>和<code>HTTP</code>认证信息。</p><h5 id="_1、服务端要做的事" tabindex="-1"><a class="header-anchor" href="#_1、服务端要做的事" aria-hidden="true">#</a> 1、服务端要做的事</h5><p>服务器同意，指定<code>Access-Control-Allow-Credentials</code>字段为<code>true</code>。</p><p>需要注意的是，如果要发送<code>Cookie</code>，<code>Access-Control-Allow-Origin</code>就不能设为星号，必须指定明确的、与请求网页一致的域名。</p><p>同时，<code>Cookie</code>依然遵循同源政策，只有用服务器域名设置的<code>Cookie</code>才会上传，其他域名的<code>Cookie</code>并不会上传，且（跨源）原网页代码中的<code>document.cookie</code>也无法读取服务器域名下的<code>Cookie</code>。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>Access-Control-Allow-Credentials: <span class="token boolean">true</span> <span class="token punctuation">;</span>
<span class="token comment"># 这里以掘金为例</span>
Access-Control-Allow-Origin: https://juejin.cn<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="_2、客户端需要做的事" tabindex="-1"><a class="header-anchor" href="#_2、客户端需要做的事" aria-hidden="true">#</a> 2、客户端需要做的事</h5><p>如果要把<code>Cookie</code>发到服务器，一方面要服务器开启允许携带 cookie，开发者必须在<code>AJAX</code>请求中打开<code>withCredentials</code>属性。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
xhr<span class="token punctuation">.</span>withCredentials <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_9、非简单请求" tabindex="-1"><a class="header-anchor" href="#_9、非简单请求" aria-hidden="true">#</a> 9、非简单请求</h4><p>也就是说浏览器会发送<strong>两次</strong><code>http</code>请求。</p><ol><li>第一次<code>Request Method: OPTIONS</code></li><li>第二次再请求所需内容。</li></ol><p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是<code>PUT</code>或<code>DELETE</code>，或者<code>Content-Type</code>字段的类型是<code>application/json</code>。</p><p>非简单请求的<code>CORS</code>请求，会在正式通信之前，增加一次<code>HTTP</code>查询请求，称为<strong>预检请求</strong> <code>（preflight）</code>。</p><p>。。。</p><h4 id="_10、代码演示" tabindex="-1"><a class="header-anchor" href="#_10、代码演示" aria-hidden="true">#</a> 10、代码演示</h4><p>https://www.jianshu.com/p/c68d404a3ab9</p>`,36);function b(k,_){const n=i("ExternalLinkIcon");return c(),t("div",null,[d(" @format "),p,e("h4",h,[u,a(" 5、"),e("a",m,[a("CORS"),r(n)])]),g])}const C=s(l,[["render",b],["__file","kuayujiqijiejuefangan.html.vue"]]);export{C as default};
