import{_ as l,r,o as t,c as d,a as o,b as a,d as e,f as s,e as i}from"./app-iph3vjA0.js";const c={},h=a("p",null,"前端安全之 - JWT",-1),p=i('<h4 id="jwt-json-web-token" tabindex="-1"><a class="header-anchor" href="#jwt-json-web-token" aria-hidden="true">#</a> JWT( JSON Web Token )</h4><h4 id="_01-什么是jwt" tabindex="-1"><a class="header-anchor" href="#_01-什么是jwt" aria-hidden="true">#</a> 01/ 什么是JWT</h4><ul><li><p>JWT是JSON Web Token的缩写,是一种易用且无状态的鉴权方式</p></li><li><p>用于在各方之间以JSON对象安全传输信息。这些信息可以通过数字签名进行验证和信任。</p></li><li><p>简单来说就是server端把JSON数据经过加密做成Token,以授权给client端</p></li></ul><h4 id="_02-栗子" tabindex="-1"><a class="header-anchor" href="#_02-栗子" aria-hidden="true">#</a> 02/ 栗子:</h4>',4),u={href:"https://link.zhihu.com/?target=https%3A//raw.githubusercontent.com/jpadilla/pyjwt",target:"_blank",rel:"noopener noreferrer"},_=i(`<div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>import time

import jwt

exp = int(time.time()) + 86400 * 7  # 失效时间
user = &#39;liriansu&#39;  # 用户表示
key = &#39;hunter2&#39;  # 密钥
payload = {&#39;exp&#39;: exp, &#39;user&#39;: user}  # JSON 数据
token = jwt.encode(payload, key)

print(token)
# token可能会长这样子
# eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.e30.EoKoMCjq_zGqUg5HDfqw4EN7EiG6gMjkUZle0uGJDGU
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后Client端每次在authorization header或者是query string里带上token。 Server端收到请求的时候， 用<code>payload = jwt.decode(token, key)</code>验证权限就行了。 验证通过以后，payload中就是整个JSON数据。 理论上你可以往token payload里塞任何**_非敏感**_数据。</p><h4 id="_03-使用场景" tabindex="-1"><a class="header-anchor" href="#_03-使用场景" aria-hidden="true">#</a> 03 / 使用场景</h4><ul><li><p>鉴权</p><p>用户一旦登录,后续的每个请求都需要携带jwt,允许该用户访问该令牌允许的路由,服务和资源.</p><p>单点登录是当前使用最广泛的JWT的一项功能,因为开销较小,并且能够跨域使用</p></li><li><p>信息交换</p><p>JWT是在各方之间安全传输信息的好方式,因为JWT可以签名：例如使用公钥/私钥对，所以可以确定发件人是他们自称的人。此外，由于使用标头和有效载荷计算签名，因此您还可以验证内容是否未被篡改。</p></li></ul><h4 id="_04-jwt结构" tabindex="-1"><a class="header-anchor" href="#_04-jwt结构" aria-hidden="true">#</a> 04 / JWT结构</h4><p><code> eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.e30.EoKoMCjq_zGqUg5HDfqw4EN7EiG6gMjkUZle0uGJDGU</code></p><p>如上所示,JWT输出的是三个由点分隔的<code>xxxx.yyyy.zzzz</code>Base64-URL字符串，可以在HTML和HTTP环境中轻松传递，</p><p>他们分别代表:</p><ul><li>Header <ul><li>Header通常由两部分组成：令牌的类型，即JWT。和常用的散列算法</li><li>Header部分的JSON被Base64Url编码，形成JWT的第一部分。</li></ul></li><li>Payload <ul><li>存放沟通讯息的地方</li><li>Registered claims（注册声明）</li><li>Public claims（公开声明）</li><li>Private claims（私有声明）</li></ul></li><li>Signature <ul><li>用来验证发送请求者身份，由前两部分加密形成。</li></ul></li></ul><h4 id="_04-所以综合来说" tabindex="-1"><a class="header-anchor" href="#_04-所以综合来说" aria-hidden="true">#</a> 04/ 所以综合来说，</h4><p>假如使用JWT作为鉴权方式， 有以下几个特性：</p><ol><li>Client端不用管任何加密/解密，只用存token，在请求里面带上就行了。</li><li>Server端可以实现不依赖外部存储鉴权，所有的数据都丢在token里。</li><li>也就是说鉴权这一步不需要File/MySQL/Redis之类的数据库，也能知道用户身份。</li><li>因为token带失效时间，所以需要在失效前/后再刷新token。</li></ol><h4 id="_05-常见问题" tabindex="-1"><a class="header-anchor" href="#_05-常见问题" aria-hidden="true">#</a> 05/ 常见问题</h4><h5 id="_1-jwt-安全嗎" tabindex="-1"><a class="header-anchor" href="#_1-jwt-安全嗎" aria-hidden="true">#</a> ① JWT 安全嗎?</h5><p>Base64编码方式是可逆的，也就是透过编码后发放的Token内容是可以被解析的。一般而言，我们都不建议在有效载荷内放敏感讯息，比如使用者的密码。</p><h5 id="_2-jwt-payload-內容可以被伪造嗎" tabindex="-1"><a class="header-anchor" href="#_2-jwt-payload-內容可以被伪造嗎" aria-hidden="true">#</a> ② JWT Payload 內容可以被伪造嗎？</h5><p>JWT其中的一个组成内容为Signature，可以防止通过Base64可逆方法回推有效载荷内容并将其修改。因为Signature是经由Header跟Payload一起Base64组成的。</p><h5 id="_3-如果我的-cookie-被窃取了-那不就表示第三方可以做-csrf-攻击" tabindex="-1"><a class="header-anchor" href="#_3-如果我的-cookie-被窃取了-那不就表示第三方可以做-csrf-攻击" aria-hidden="true">#</a> ③ 如果我的 Cookie 被窃取了，那不就表示第三方可以做 CSRF 攻击?</h5><p>是的，Cookie丢失，就表示身份就可以被伪造。故官方建议的使用方式是存放在LocalStorage中，并放在请求头中发送。</p><h5 id="_4-空间及长度问题" tabindex="-1"><a class="header-anchor" href="#_4-空间及长度问题" aria-hidden="true">#</a> ④ 空间及长度问题？</h5><p>JWT Token通常长度不会太小，特别是Stateless JWT Token，把所有的数据都编在Token里，很快的就会超过Cookie的大小（4K）或者是URL长度限制。</p><h5 id="_5-token失效问题" tabindex="-1"><a class="header-anchor" href="#_5-token失效问题" aria-hidden="true">#</a> ⑤ Token失效问题？</h5><p>无状态JWT令牌（Stateless JWT Token）发放出去之后，不能通过服务器端让令牌失效，必须等到过期时间过才会失去效用。</p><p>假设在这之间Token被拦截，或者有权限管理身份的差异造成授权Scope修改，都不能阻止发出去的Token失效并要求使用者重新请求新的Token。</p><h4 id="_06-jwt使用建议" tabindex="-1"><a class="header-anchor" href="#_06-jwt使用建议" aria-hidden="true">#</a> 06/ JWT使用建议</h4><ul><li>不要存放敏感信息在Token里。</li><li>Payload中的exp时效不要设定太长。</li><li>开启Only Http预防XSS攻击。</li><li>如果担心重播攻击（replay attacks ）可以增加jti（JWT ID），exp（有效时间） Claim。</li><li>在你的应用程序应用层中增加黑名单机制，必要的时候可以进行Block做阻挡（这是针对掉令牌被第三方使用窃取的手动防御）。</li></ul>`,26);function k(T,J){const n=r("ExternalLinkIcon");return t(),d("div",null,[h,o(" more "),p,a("p",null,[e("当Client端登录完成以后，Server端要返回一个7天有效的token，那么对应的Python的样例代码会是这样的： （"),a("a",u,[e("使用了PyJWT包：pip install pyjwt"),s(n)]),e("）")]),_])}const m=l(c,[["render",k],["__file","JWTjianquan.html.vue"]]);export{m as default};
