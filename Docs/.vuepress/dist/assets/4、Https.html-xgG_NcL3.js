import{_ as l,r as a,o as s,c as n,a as p,b as t,d as e,f as r,w as o,e as h}from"./app-1sZ14lpL.js";const c={},d=t("h2",{id:"_1、http-协议存在的一些问题",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#_1、http-协议存在的一些问题","aria-hidden":"true"},"#"),e(" 1、Http 协议存在的一些问题")],-1),u=t("ul",null,[t("li",null,"http 报文明文发送,可能会被第三方窃听"),t("li",null,"http 报文可能会被第三方截取之后修改通信内容,接收方没有办法发现报文内容的修改"),t("li",null,"http 还存在认证问题,第三方可以冒充他人参与通信")],-1),_=t("h2",{id:"_2、https-简介",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#_2、https-简介","aria-hidden":"true"},"#"),e(" 2、Https 简介")],-1),g=t("li",null,"使用 TLS 和 SSL 协议,所有的信息都是加密的,第三方没有办法窃听,并且他提供了一种校验机制,信息一旦被篡改,通信双方立刻就会发现",-1),S=t("li",null,"它还配备了身份证书,防止身份被冒充的情况出现",-1),m=t("li",null,"Https 组成： HTTP 协议 + 混合加密 + CA 证书 + 数字签名",-1),T=h('<h2 id="_3、ssl-加密方式" tabindex="-1"><a class="header-anchor" href="#_3、ssl-加密方式" aria-hidden="true">#</a> 3、SSL 加密方式</h2><ul><li><p>对称加密</p><blockquote><p>对称加密即客户端和服务端同时约定同一种秘钥,客户端发送信息给服务端使用该秘钥加密,服务端收到信息后在用秘钥解密,整个流程类似下面这个例子: 期末考试,小明找小红希望数学考试的时候小红可以帮他,两个人考试前约定了一把秘钥:小红把所有的答案都加上 250; 小红把答案通过秘钥加密: 15 + 250 = 265 --&gt; 偷偷的丢给小明 小明通过秘钥解密: 265- 250 = 15 ---&gt; 小明得到正确答案</p></blockquote><ul><li><p>对称加密加密效率高速度快</p></li><li><p>❗❗❗ 但是该加密方式存在一些漏洞,假如别人获取到了加密方式,然后再用该方案来解密,那数据信息岂不是还是可以被截取修改,因此出现了非对称加密的方案</p><p><img src="https://raw.githubusercontent.com/tengyuanOasis/image/master/image/image-20220213154442752.png" alt="image-20220213154442752"></p></li></ul></li><li><p>非对称加密</p><blockquote><p>非对称加密就是有两把密钥，公钥和私钥。私钥自己藏着，不告诉任何人；而公钥可以公开给别人。</p><p>非对称加密即通信双方各自有一个秘钥和公钥,公钥用来对信息进行加密,私钥用来对信息进行解密; 通信的时候, 公钥是随着信息一起发送给对方的,即公钥是公开的, 但是私钥是不会公开的 假如 A 发送信息给 B:</p><ul><li>A 把自己发送的信息连同公钥(加密方式)一起发送给 B,</li><li>B 方收到信息和公钥的时候,把返回的信息通过 A 的公钥对信息进行加密</li><li>返回信息给 A 的同时把自己的公钥和密文一起发送给 A</li><li>A 收到 B 的加密信息之后,再通过自己的私钥对信息进行解密,如果还需要和 B 进行通信,再用 B 的公钥加密即可</li></ul></blockquote><ul><li>非对称加密相对于对称加密安全度是高了一点,但是如果拦截方把数据拦截下来,将自己的数据用拦截下来的公钥加密后返回给发送方,放松方并不能识别出来是不是目标通信对象发来的信息,因此还需要<strong>数字签名</strong>来作保障</li></ul><p><img src="https://raw.githubusercontent.com/tengyuanOasis/image/master/image/image-20220213154503026.png" alt="image-20220213154503026"></p></li></ul><h2 id="_4、数字签名" tabindex="-1"><a class="header-anchor" href="#_4、数字签名" aria-hidden="true">#</a> 4、数字签名</h2><p>数字签名是附加在报文上面的特殊加密校验码.可以防止报文被篡改,如果恶意攻击在传输过程中篡改了报文,那么校验的时候就不再匹配,因此可以确认报文被篡改;</p><p><strong>数字签名加密过程:</strong></p><ul><li>发送端将报文通过算法（比如通过 HASH 函数）提取为定长的摘要；</li><li>发送端将摘要应用签名算法，以私有密钥作为参数生成一个签名；</li><li>计算得出签名后，将签名附加在报文末端发送给接收方；</li><li>接收端收到报文后，对签名进行检查。接收端通过公开密钥解码签名。然后比对报文生成的摘要是否与签名一致便可判断报文是否被篡改。</li></ul><h2 id="_5、数字-ca-证书" tabindex="-1"><a class="header-anchor" href="#_5、数字-ca-证书" aria-hidden="true">#</a> 5、<strong>数字（CA）证书:</strong></h2><p>数字证书是由权威机构给某网站颁发的一种认可凭证。它主要包含一些认证信息，比如：对象的名称（服务器、组织、个人等）、过期时间、证书颁发者、来自证书发布者的数字签名。</p><img src="https://raw.githubusercontent.com/tengyuanOasis/image/master/image/image-20220213154553609.png" alt="image-20220213154553609" style="zoom:50%;"><p>上面的图片就是www.raw.githubusercontent.com的证书。</p><p>我们可以看到在上面讲到数字签名的时候，似乎就可以保证报文的安全了。为什么还需要数字证书呢？这个设想一下这个场景：比如某人 A 把发送到浏览器的公有密钥进行了替换，同时 A 在给浏览器发送报文时使用自己的私有密钥对报文进行数字签名，那么浏览器就不能确认报文是否来自于真实服务器。这个时候就可以使用数字证书进行验证，因为数字证书中保存了真实服务器的信息。</p><h2 id="_6、https-的工作流程" tabindex="-1"><a class="header-anchor" href="#_6、https-的工作流程" aria-hidden="true">#</a> 6、HTTPS 的工作流程</h2><p><strong>建立安全传输</strong> 在 TCP 连接建立完成以后，在 HTTPS 协议中，客户端和服务端会初始化 SSL 层，也就是安全层。</p><p><strong>SSL 握手</strong> 在发送报文之前，客户端和服务端会进行一次 SSL 握手，在这个过程中主要完成以下工作：</p><ul><li><p>交换协议版本号；</p></li><li><p>选择一个两端都了解的密码；</p></li><li><p>对两端的身份进行认证；</p></li><li><p>生成临时会话密钥，以便加密信道（建立完安全通道后，传输报文时使用对称加密）；</p></li></ul><p>在 SSL 会进行很多工作，处理交换一些必要的信息之外，还会对身份进行认证。</p><p>这里的认证是通过数字证书进行的，在客户端获取证书后，会采用相应的算法对服务端的身份信息进行验证：</p><ul><li><p>日期检测：客户端会检查证书的有效期是否合法；</p></li><li><p>签名颁布者可信度检测：浏览器会附带一个签名颁发机构的授信列表，如果浏览器收到了位置的颁发机构签发的证书，那么它会显示一条警告信息；</p></li><li><p>签名检测：客户端对签名使用签名颁发机构的公开密钥，然后将其与校验码比较，以便验证证书是否合法；</p></li><li><p>站点身份检测：客户端验证数字证书中的域名是否与服务端的域名匹配；</p></li></ul><p>身份认证完成后，客户端与服务端进行密码协商，确定本次连接采用哪种加密算法进行通信。</p><p><strong>开始通信</strong> SSL 握手完成后，就完成建立了 HTTPS 通道，客户端与服务端就会根据协商的加密算法进行通信。</p><h2 id="_6、总结" tabindex="-1"><a class="header-anchor" href="#_6、总结" aria-hidden="true">#</a> 6、总结</h2><p>相较于 HTTP 协议，HTTPS 确保了报文的机密性以及完整性。HTTPS 确保这些的依赖就是 SSL/TSL 协议，SSL/TSL 安全协议搭配数字证书保证了报文在传输过程中的绝对安全。</p>',22);function f(H,b){const i=a("font");return s(),n("div",null,[p(" @format "),d,u,_,t("ul",null,[t("li",null,[e("HTTPS 指的是超文本传输"),r(i,{color:"red"},{default:o(()=>[e("安全协议")]),_:1}),e(",HTTPS 是基于 HTTTP 协议的,不过它会使用 TLS/SSL 来对数据进行加密,即 Http+TLS/SSL(混合加密)")]),g,S,m]),T])}const x=l(c,[["render",f],["__file","4、Https.html.vue"]]);export{x as default};
