import{_ as s,r,o as c,c as i,a as u,b as e,d as t,f as l,w as n,e as d}from"./app-iph3vjA0.js";const p={},_=e("h4",{id:"_01、vue-响应式",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_01、vue-响应式","aria-hidden":"true"},"#"),t(" 01、Vue 响应式")],-1),h=e("p",null,[e("img",{src:"https://cn.vuejs.org/images/data.png",alt:""})],-1),g=e("ol",null,[e("li",null,"什么是响应式数据")],-1),m=e("p",null,[t("“响应式”，是指当"),e("strong",null,"数据改变后"),t("，Vue 会通知到使用该数据的代码。")],-1),f=e("p",null,[t("例如，视图渲染中使用了数据，数据改变后，"),e("strong",null,"视图也会自动更新"),t("。")],-1),b={href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty",target:"_blank",rel:"noopener noreferrer"},O=d('<ol start="2"><li>原理：</li></ol><blockquote><p>Vuejs 在实例化的过程中，会对实例化对象选项中的 data 属性进行遍历，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。</p><p>同时每一个实例对象都有一个 watcher 实例对象，他会在模板编译的过程中,用 getter 去访问 data 的属性，watcher 此时就会把用到的 data 属性记为依赖，这样就建立了视图与数据之间的联系。</p><p>当之后我们渲染视图的数据依赖发生改变（即数据的 setter 被调用）的时候，watcher 会对比前后两个的数值是否发生变化，然后确定是否通知视图进行重新渲染这样就实现了所谓的数据对于视图的驱动。</p><p>通俗地讲，它意味着我们在普通 HTML 模板中使用特殊的语法将 DOM “绑定”到底层数据。</p><p>一旦创建了绑定，DOM 将与数据保持同步。每当修改了数据，DOM 便相应地更新。这样我们应用中的逻辑就几乎都是直接修改数据了，不必与 DOM 更新搅在一起。这让我们的代码更容易撰写、理解与维护。</p></blockquote><ol start="3"><li>详细流程</li></ol><p><img src="https://raw.githubusercontent.com/tengyuanOasis/image/master/image-20211216134508994.png" alt="image-20211216134508994"></p><blockquote><p>当 Vue 实例创建时，Observe 通过<code>Object.defineProperty</code>劫持当前已存在的所有属性，并收集与该数据关联的的 watcher，当用户取用数据时，调用 getter 函数，并添加判断有没有订阅者，无则添加 watcher， 当用户修改 data 数据，调用到 setter 属性，同时调用 Dep.notify()通知视图层数据更新，重新编译最新数据，完成视图更新</p></blockquote>',5),V=e("p",null,"名词解释",-1),y=e("ol",null,[e("li",null,"通过递归调用 Objet.defineProperety 对所有已存在属性数据劫持"),e("li",null,[t("getter： 获取数据时，调用 getter，调用"),e("code",null,"Dep.depend()"),t("添加当前依赖")]),e("li",null,[t("setter： 数据更新是，调用 setter，修改 data 数据并调用"),e("code",null,"Dep.notify()"),t("通知视图更新")])],-1),k=e("ol",null,[e("li",null,"当对 data 上的对象进行修改值的时候会触发它的 setter，那么取值的时候自然就会触发 getter 事件，所以我们只要在最开始进行一次 render，那么所有被渲染所依赖的 data 中的数据就会被 getter 收集到 Dep 的 subs 中去。在对 data 中的数据进行修改的时候 setter 只会触发 Dep 的 subs 的函数。")],-1),D=e("ol",null,[e("li",null,"在自身实例化时往属性订阅器(dep)里面添加自己"),e("li",null,"自身必须有一个 update()方法"),e("li",null,"待属性变动 dep.notice()通知时，能调用自身的 update()方法，并触发 Compile 中绑定的回调，则功成身退")],-1),j=e("p",null,[e("img",{src:"https://raw.githubusercontent.com/tengyuanOasis/image/master/image-20211217111652559.png",alt:"image-20211217111652559"})],-1);function v(w,x){const a=r("ExternalLinkIcon"),o=r("font");return c(),i("div",null,[u(" @format "),_,h,g,e("blockquote",null,[m,f,e("p",null,[t("Vue.js 的响应式原理依赖于"),e("a",b,[t("Object.defineProperty"),l(a)]),t("，这也是 Vue.js 不支持 IE8 以及更低版本浏览器的原因。Vue 通过设定对象属性的 setter/getter 方法来监听数据的变化，==通过 getter 进行依赖收集，而每个 setter 方法就是一个观察者==，在数据变更的时候通知订阅者更新视图。")])]),O,e("blockquote",null,[V,e("ul",null,[e("li",null,[t("Observer ："),l(o,{color:"red"},{default:n(()=>[t("  数据劫持，将数据变为可观察的  ")]),_:1}),y]),e("li",null,[t("Dep ："),l(o,{color:"red"},{default:n(()=>[t("  用于收集用户依赖（当 data 属性被页面使用，编译器会创建 watcher，并存储在 Dep 中） ")]),_:1}),k]),e("li",null,[t("Watcher： "),l(o,{color:"red"},{default:n(()=>[t("  订阅者, 负责监控数据变化并更新视图  ")]),_:1}),D]),e("li",null,[t("Compile: "),l(o,{color:"red"},{default:n(()=>[t("  负责将 el 编译虚拟 dom 并最终渲染视图")]),_:1})])])]),j])}const C=s(p,[["render",v],["__file","2、Vuexiangyingshiyuanli.html.vue"]]);export{C as default};
