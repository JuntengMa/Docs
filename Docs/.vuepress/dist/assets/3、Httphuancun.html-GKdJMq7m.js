import{_ as n,r as a,o as r,c as l,a as d,b as e,d as t,f as o,w as p,e as i}from"./app-1sZ14lpL.js";const h={},g={href:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching",target:"_blank",rel:"noopener noreferrer"},u=i('<h4 id="_1、为什么要缓存" tabindex="-1"><a class="header-anchor" href="#_1、为什么要缓存" aria-hidden="true">#</a> 1、为什么要缓存</h4><blockquote><p>出于性能优化考虑，使用 http 缓存，下次请求使用上一次请求资源副本</p></blockquote><h4 id="_2、http-缓存种类" tabindex="-1"><a class="header-anchor" href="#_2、http-缓存种类" aria-hidden="true">#</a> 2、http 缓存种类</h4><blockquote><p>HTTP 缓存的类型很多，根据是否需要重新向服务器发起请求来分类包括两种：<strong>强制缓存</strong> 和 <strong>对比缓存（协商缓存）</strong></p></blockquote><h4 id="_3、假设浏览器有一个缓存数据库用于本地缓存-先看看浏览器请求资源的情况" tabindex="-1"><a class="header-anchor" href="#_3、假设浏览器有一个缓存数据库用于本地缓存-先看看浏览器请求资源的情况" aria-hidden="true">#</a> 3、假设浏览器有一个缓存数据库用于本地缓存，先看看浏览器请求资源的情况：</h4><p><img src="https://raw.githubusercontent.com/tengyuanOasis/image/master/202202241355492.png" alt="image-20220224135545420"></p><h4 id="_4、强制缓存" tabindex="-1"><a class="header-anchor" href="#_4、强制缓存" aria-hidden="true">#</a> 4、强制缓存</h4><p>在浏览器已经缓存数据的情况下，使用强制缓存去请求数据的流程是这样的：</p><p><img src="https://raw.githubusercontent.com/tengyuanOasis/image/master/202202241356816.png" alt="image-20220224135643725"></p><p>从流程图可以看到，强制缓存，在缓存数据未失效的情况下，可以直接使用缓存数据，不需要再请求服务器，那么浏览器是如何判断缓存数据是否失效呢？ 对于强制缓存来说，响应 header 中会有两个字段来标明失效规则（Expires/Cache-Control）：</p><ul><li>Expires：</li></ul>',11),m=e("p",null,"👉 简述：",-1),f=e("p",null,"Expires 是 HTTP1.0 的产物，现在默认浏览器均默认使用 HTTP 1.1，所以它的作用基本忽略。但是很多网站还是对它做了兼容。",-1),_=e("p",null,"👉 缺陷：",-1),b=e("ul",null,[e("li",null,"到期时间是服务端生成的，修改客户端时间，可能会导致缓存失效")],-1),x=i(`<ul><li>Cache-Control：</li></ul><blockquote><p>Cache-Control 出现于 HTTP/1.1，常见字段是 max-age，单位是秒，很多 web 服务器都有默认配置，优先级高于 Expires，表示的是相对时间。</p><p>Cache-Control 常见的取值有 private、public、no-cache、max-age，no-store，默认为 private。</p><p>（1） max-age：用来设置资源（representations）可以被缓存多长时间，单位为秒；</p><p>​ 如 Cache-Control:max-age=3600 代表资源的有效期是 3600 秒，取的是响应头中的 Date，请求发送的时间，表示当前资源 在 Date ~ Date +3600s 这段时间里都是有效的。</p><p>（2） s-maxage：和 max-age 是一样的，不过它只针对代理服务器缓存而言； （3）public：指示响应可被<strong>任何缓存区</strong>缓存； （4）private：只能针对个人用户，而不能被代理服务器缓存； （5）no-cache：强制客户端直接向服务器发送请求,也就是说每次请求都必须向服务器发送。服务器接收到 请求，然后判断资源是否变更，是则返回新内容，否则返回 304，未变更。这个很容易让人产生误解，使人误 以为是响应不被缓存。实际上 <code>Cache-Control: no-cache</code>是会被缓存的，只不过每次在向客户端（浏览器）提供响应数据时，缓存都要向服务器评估缓存响应的有效性。 （6）no-store：禁止一切缓存（这个才是响应不被缓存的意思）。</p></blockquote><p>举个例子： 比如一个资源响应头是：</p><div class="language-lasso line-numbers-mode" data-ext="lasso"><pre class="language-lasso"><code>cache-control: public , max-age=31536000
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>那么这个资源会被缓存 31536000 秒（365 天），在 365 天内再次请求这条数据，都会直接获取缓存数据库中的数据，直接使用。 那么我们试试再次访问资源，会有以下的响应： <img src="https://image-static.segmentfault.com/160/128/1601280277-5e40f5a32b32e_articlex" alt="img"></p><p>可以看到 HTTP 状态码是 200，Size 这个字段显示：disk cache，说明 HTTP 响应报文大小是 0，浏览器确实走了强制缓存，没有再跟浏览器交互。 我们上面说了，不同的访问/刷新手段，会使浏览器使用不同的缓存策略，要让浏览器走强制缓存对请求方式有一个要求: <strong>在 URI 输入栏中输入然后回车/通过书签访问</strong></p><h4 id="_5、对比缓存" tabindex="-1"><a class="header-anchor" href="#_5、对比缓存" aria-hidden="true">#</a> 5、对比缓存：</h4><p>在浏览器已经缓存数据的情况下，使用对比缓存去请求数据的流程是这样的： <img src="https://image-static.segmentfault.com/548/182/548182949-5adfe1970b276_articlex" alt="img"></p><blockquote><p>有同学可能会问，基于对比缓存的流程下，不管是否使用缓存，都需要向服务器发送请求，那么还用缓存干什么？ 这个问题，我们现在来探讨一下。 对比缓存，顾名思义，需要进行比较判断是否可以使用缓存。 浏览器第一次请求数据时，服务器会将缓存标识与数据一起返回给浏览器，浏览器将二者备份至缓存数据库中。 当浏览器再次请求数据时，浏览器将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，判断成功后，返回 304 状态码，通知客户端比较成功，可以使用缓存数据。</p></blockquote><p>举个例子： 第一次访问： <img src="https://image-static.segmentfault.com/260/447/2604473468-5e40f5a45288c_articlex" alt="img"></p><p>第二次访问： <img src="https://image-static.segmentfault.com/335/478/3354782402-5e40f5a535480_articlex" alt="img"></p><p>对比缓存，响应 header 中会有两个字段来标明规则</p><ul><li><p>Last-Modified / If-Modified-Since</p><p>服务器用 <code>Last-Modified</code>告诉浏览器资源 <code>最后修改时间</code></p></li></ul><blockquote><p><strong>服务器响应请求时</strong>，会通过 <code>Last-Modified</code>HTTP 头告诉浏览器资源的<strong>最后修改时间</strong>，浏览器本地对资源缓存起来，之后再请求的时候，会带上一个 HTTP 头 <code>If-Modified-Since</code>，这个值就是服务器上一次给的 <code>Last-Modified</code>的时间，服务器会拿着浏览器传过来的时间比对资源当前最后的修改时间，如果大于 <code>If-Modified-Since</code>，则说明资源修改过了，浏览器不能再使用缓存，服务器重新一份完整的资源浏览器，否则浏览器可以继续使用缓存，并返回 304 状态码</p></blockquote><ul><li>Etag / If-None-Match（<strong>优先级高于 Last-Modified / If-Modified-Since</strong>）</li></ul><blockquote><p><strong>服务器响应请求时</strong>，通过 <code>Etag</code>HTTP 头部告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定），浏览器再次请求时，就会带上一个头 <code>If-None-Match</code>，这个值就是服务器上一次给的 <code>Etag</code>的值，服务器比对一下资源当前的 Etag 是否跟 If-None-Match 一致，不一致则说明资源修改过了，浏览器不能再使用缓存，否则浏览器可以继续使用缓存，并返回 304 状态码</p></blockquote><p>值得注意的是：<strong>Etag 的校验优先级高于 Last-Modified</strong> 看个例子： 第一次请求，服务器的响应头包含了 <img src="https://image-static.segmentfault.com/378/540/3785407674-5e40f5a5b622c_articlex" alt="img"></p><p>第二次请求，浏览器的请求头 <img src="https://image-static.segmentfault.com/251/216/251216282-5e40f5a63e9fb_articlex" alt="img"></p><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h3><p>优先级：</p><blockquote><p>cache-control &gt; expires &gt; Etag &gt; last-modified</p></blockquote><p>我们再看一下 HTTP 缓存的一个总概流程图：</p><p><img src="https://image-static.segmentfault.com/155/525/1555253303-5b4b22be9160d_articlex" alt="img"></p><ul><li>HTTP 缓存主要分强制缓存和对比缓存</li><li>强制缓存的 HTTP 相关头部 Cache-Control，Exipres（HTTP1.0）,浏览器直接读本地缓存，不会再跟服务器端交互，状态码 200。</li><li>对比缓存的 HTTP 相关头部 Etag / If-None-Match 、Last-Modified / If-Modified-Since， (Etag 优先级比 Last-Modified / If-Modified-Since 高)，每次请求需要让服务器判断一下资源是否更新过，从而决定浏览器是否使用缓存，如果是，则返回 304，否则重新完整响应。</li></ul>`,24);function T(k,C){const c=a("ExternalLinkIcon"),s=a("font");return r(),l("div",null,[d(" @format "),e("p",null,[e("a",g,[t("MDN"),o(c)])]),u,e("blockquote",null,[m,f,e("p",null,[t("它的值为"),o(s,{color:"red"},{default:p(()=>[t("服务端返回的到期时间")]),_:1}),t("，即下一次请求时，请求时间小于服务端返回的到期时间，直接使用缓存数据。")]),_,b]),x])}const H=n(h,[["render",T],["__file","3、Httphuancun.html.vue"]]);export{H as default};
