<!-- @format -->

##### 1、事件

**JavaScript 是一门单线程的，非阻塞的脚本语言**

> 单线程： 任何时候都只有一个主线程（执行栈）处理所有任务
>
> 非阻塞：有异步任务时，js 会产生一个任务队列，任务队列中的任务不会立即执行，当主线程任务执行完毕，则检查任务队列中是否
>
> 有回调，有则压入主线程执行

> **JS 执行机制可以看做一个主线程加上一个任务队列.**
>
> 同步任务都在主线程(这里的主线程就是 JS 引擎线程)上执行，会形成一个`执行栈`
>
> 主线程之外，事件触发线程管理着一个`任务队列`，只要异步任务有了运行结果，就在`任务队列`之中放一个事件回调
>
> 一旦`执行栈`中的所有同步任务执行完毕(也就是 JS 引擎线程空闲了)，系统就会读取`任务队列`，将可运行的异步任务(任务队列中的事件
>
> 回调，只要任务队列中有事件回调，就说明可以执行) 添加到执行栈中，开始执行。

> js 执行期间，同步任务都在执行栈中执行，异步任务则被压入任务队列，当同步任务执行完成，则读取任务队列中的任务，当任务队
>
> 列中有事件回调，则将其添加到执行栈中开始执行

##### 2、什么是事件循环

取自《深入浅出 VueJs》p176，什么是事件循环？

> 我们都知道 JavaScript 是一门单线程且非阻塞的脚本语言，这意味着 JavaScript 代码在执行的任何时候都只有一个主线程来处理所有任务。而非阻塞是指当代码需要处理异步任务时，主线程会挂起（pending）这个任务，当异步任务处理完毕后，主线程再根据一定规则去执行相应回调。
>
> 当任务处理完毕后，JavaScript 会将这个事件加人一个队列中，我们称这个队列为事件队列。被放入事件队列中的事件不会立刻执行其回调，而是等待当前执行栈中的所有任务执行完毕后，主线程会去查找事件队列中是否有任务。
>
> 异步任务有两种类型：微任务（microtask）和宏任务（macrotask）。不同类型的任务会被分配到不同的任务队列中。
>
> 当执行栈中的所有任务都执行完毕后，会去检查微任务队列中是否有事件存在，如果存在， 则会依次执行微任务队列中事件对应的回调，直到为空。然后去宏任务队列中取出一个事件，把对应的回调加人当前执行栈，当执行栈中的所有任务都执行完毕后，检查微任务队列中是否有事件存在。无限重复此过程，就形成了一个无限循环，这个循环就叫作事件循环。

##### 3、宏任务、微任务

> **宏任务**
>
> 我们可以将每次**执行栈执行的代码**当做是一个宏任务(包括每次从事件队列中获取一个事件回调并放到执行栈中执行)， 每一个宏任务会从头到尾执行完毕，不会执行其他
>
> 由于`JS引擎线程`和`GUI渲染线程`是互斥的关系，浏览器为了能够使`宏任务`和`DOM任务`有序的进行，会在一个`宏任务`执行结果后，在下一个`宏任务`执行前，`GUI渲染线程`开始工作，对页面进行渲染
>
> 宏任务 --> GUI 渲染 --> 宏任务
>
> **常见的宏任务**
>
> 主代码块
>
> - setTimeout
> - setInterval
> - setImmediate ()-Node
> - requestAnimationFrame ()-浏览器
>
> **微任务**
>
>  我们已经知道`宏任务`结束后，会执行渲染，然后执行下一个`宏任务`， 而微任务可以理解成在当前`宏任务`执行后立即执行的任务
>
> 当一个`宏任务`执行完，会在渲染前，将执行期间所产生的所有`微任务`都执行完
>
> 宏任务 -> 微任务 -> GUI 渲染 -> 宏任务 -> ...
>
> **常见微任务**
>
> - process.nextTick ()-Node
> - Promise.then()
> - catch
> - finally
> - Object.observe (此 api 已废弃，目前更通用的 api 为 es6 的 proxy)
> - MutationObserver

4、为什么要区分宏任务和微任务

> 事件循环中的任务被分为宏任务和微任务，是为了给高优先级任务一个插队的机会：微任务比宏任务有更高优先级。

https://segmentfault.com/a/1190000041522327

5、练习

```js
setTimeout(() => {
	console.log(1);
}, 0);

Promise.resolve().then(() => {
	console.log(2);
});

const test = () => {
	return new Promise((resolve, reject) => {
		console.log(3);
		resolve(4);
		console.log(5);
		reject(6);
		console.log(7);
	});
};

test()
	.then((val) => {
		console.log(8);
		console.log(val);
	})
	.catch((err) => {
		console.log('err', err);
	})
	.finally(() => {
		console.log(9);
	});

console.log(10);
```

考察知识点：

1、同步任务、异步任务

2、宏任务微任务

3、`Promise构造函数是同步执行的，then方法是异步执行的`

4、`Promise resolve reject执行问题`
