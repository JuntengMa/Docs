<!-- @format -->

# JS 作用域、执行上下文、this

##### 1、什么是执行上下文

> 当我们执行一个 js 函数或变量时，JavaScript 会生成一个与该方法对应的**执行环境**（context），又叫做执行上下文。
>
> 执行上下文决定了这些函数或变量可以访问哪些数据，以及它们的行为;
>
> 每当 Javascript 代码在运行的时候，它都是在执行上下文中运行。

##### 2、执行上下文类型

> - **全局上下文**
>
>   - 这是默认或者说基础的上下文，任何不在函数内部的代码都在全局上下文中。
>
>   - 它会执行两件事：
>
>     - 创建一个全局的 window 对象（浏览器的情况下）
>     - 设置 `this` 的值等于这个全局对象。
>
>   - 一个程序中只会有一个全局执行上下文。
>
> - **函数上下文**
>   - 每当一个函数被调用时, 都会为该函数创建一个新的上下文。
>   - 每个函数都有它自己的执行上下文，不过是在函数被调用时创建的。
>   - 函数上下文可以有任意多个。
>   - 每当一个新的执行上下文被创建，它会按定义的顺序（将在后文讨论）执行一系列步骤。
> - **Eval 函数执行上下文**
>   - 执行在 `eval` 函数内部的代码也会有它属于自己的执行上下文，但由于 JavaScript 开发者并不经常使用 `eval`，所以在这里我不会讨论它。

##### 3、什么是执行栈

> 执行栈，也就是在其它编程语言中所说的“调用栈”，是一种拥有 LIFO（后进先出）数据结构的栈，被用来存储代码运行时创建的所有执行上下文。
>
> 当 JavaScript 引擎第一次遇到你的脚本时，它会创建一个全局的执行上下文并且压入当前执行栈。每当引擎遇到一个新的函数调用，它会为该函数创建一个新的执行上下文，并压入栈的**顶部**。
>
> 引擎会执行那些执行上下文位于栈顶的函数。当该函数执行结束时，执行上下文从栈中弹出，继续执行当前栈中的下一个上下文。

![image-20220214111216450](https://raw.githubusercontent.com/tengyuanOasis/image/master/image-20220214111216450.png)

让我们通过下面的代码示例来理解：

```js
let a = 'Hello World!';

function first() {
	console.log('Inside first function');
	second();
	console.log('Again inside first function');
}

function second() {
	console.log('Inside second function');
}

first();
console.log('Inside Global Execution Context');
```

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/20/165f539572076fe3~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

> 上述代码的执行上下文栈。
>
> 当上述代码在浏览器加载时，JavaScript 引擎创建了一个全局执行上下文并把它压入当前执行栈。当遇到 `first()` 函数调用时，JavaScript 引擎为该函数创建一个新的执行上下文并把它压入当前执行栈的顶部。
>
> 当从 `first()` 函数内部调用 `second()` 函数时，JavaScript 引擎为 `second()` 函数创建了一个新的执行上下文并把它压入当前执行栈的顶部。当 `second()` 函数执行完毕，它的执行上下文会从当前栈弹出，并且控制流程到达下一个执行上下文，即 `first()` 函数的执行上下文。
>
> 当 `first()` 执行完毕，它的执行上下文从栈弹出，控制流程到达全局执行上下文。一旦所有代码执行完毕，JavaScript 引擎从当前栈中移除全局执行上下文。

##### 4、作用域

> 作用域就是用来规定 js 执行过程中，代码可访问到的变量、函数的规则

作用域主要两类

- 词法作用域

  > 词法作用域，**函数声明时**所在的位置决定的，Js 作用域为词法作用域，

- 动态作用域

  > 动态作用域是在**函数执行**的时候确认的，

##### 5、作用域链

> 上下文中的代码在执行的时候，会创建变量对象的一个作用域链，**用于决定各级上下文代码访问变量和函数时的顺序；**
>
> 代码正在执行的上下文的变量对象始终位于作用域链的最前端；
>
> 全局上下文的变量对象始终是作用域链的最后一个变量对象；

![image-20220214112806939](https://raw.githubusercontent.com/tengyuanOasis/image/master/image-20220214112806939.png)

> 以上代码涉及 3 个上下文：
>
> 全局上下文，changeColor() 的局部上下文和 swapColors() 的局部上下文。
>
> 全局上下文：中有一个变量`color`和一个函数`changeColor()`。
>
> changeColor()的局部上下文: 有一个变量`anotherColor`和一个函数`swapColors()`，但在这里可以访问全局上下文中的变量 color。
>
> swapColors()的局部上下文中有一个变量 tempColor，只能在这个上下文中访问到。
>
> 全局上下文和 changeColor()的局部上下文都无法访问到 tempColor。而在 swapColors()中则可以访问另外两个上下文中的变量，因
>
> 为它们都是父上下文，图 4-3 展示了前面这个例子的作用域链。

![image-20220214112859902](https://raw.githubusercontent.com/tengyuanOasis/image/master/image-20220214112859902.png)

> 上图中的矩形表示不同的上下文。内部上下文可以通过作用域链访问外部上下文中的一切，但外部上下文无法访问内部上下文中的任何东西。上下文之间的连接是线性的、有序的。每个上下文都可以到上一级上下文中去搜索变量和函数，但任何上下文都不能到下一级上下文中去搜索。swapColors()局部上下文的作用域链中有 3 个对象：swapColors()的变量对象、changeColor()的变量对象和全局变量对象。swapColors()的局部上下文首先从自己的变量对象开始搜索变量和函数，搜不到就去搜索上一级变量对象。changeColor()上下文的作用域链中只有 2 个对象：它自己的变量对象和全局变量对象。因此，它不能访问 swapColors()的上下文。

##### 6、 总结:

- 在执行一段代码时，JS 引擎会首先**创建一个执行栈**,然后 JS 引擎会创建一个**全局执行上下文**，并 push 到执行栈中

- 这个过程 JS 引擎会为这段代码中**所有变量**分配内存并赋一个初始值（undefined）

- 在创建完成后，JS 引擎会进入**执行阶段**，这个**过程 JS 引擎会逐行的执行代码**，即为之前分配好内存的变量逐个赋值(真实值)。

- 如果这段代码中存在 function 的声明和调用，那么 JS 引擎会创建一个**函数执行上下文**，并 push 到执行栈中，其创建和执行过程跟全局执行上下文一样。但有特殊情况，即当函数中存在对其它函数的调用时，JS 引擎会在父函数执行的过程中，将子函数的全局执行上下文 push 到执行栈，这也是为什么子函数能够访问到父函数内所声明的变量。

- 还有一种特殊情况是，在子函数执行的过程中，父函数已经 return 了，这种情况下，JS 引擎会将父函数的上下文从执行栈中移除，与此同时，JS 引擎会为还在执行的子函数上下文创建一个闭包，这个闭包里保存了父函数内声明的变量及其赋值，子函数仍然能够在其上下文中访问并使用这边变量/常量。当子函数执行完毕，JS 引擎才会将子函数的上下文及闭包一并从执行栈中移除。

https://juejin.cn/post/6844903682283143181#heading-10
