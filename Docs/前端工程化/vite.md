1、什么是vite？

> vite是一个前端构建工具，前端工程化方案的其中一种，基于浏览器ESM能力和预编译能力，快速启动web服务。

2、为什么要用vite，解决了什么问题？

> webpack，vite两者对比如下
>
> 1. 冷启动速度：
>    - webpack项目启动时需要对整个项目进行编译，当项目体积越来越大，通常需要很长时间才能启动开发服务器，HMR速度也变得很慢，严重影响开发效率
>    - vite通过利用原生ESM模块和懒编译技术，只在文件被请求时编译，实现了快速的冷启动
>    - 如a、b、c三个页面，Vite在启动时不会立即编译这些页面文件。Vite采用了懒编译策略，即只有当页面被访问时，相关的文件才会被编译。这意味着如果页面在服务器启动时没有被访问，它们的编译将被推迟到页面首次请求时进行。
> 2. HMR
>    - vite的HMR响应和更新更快，几乎无感知
> 3. 依赖预构建：
>    - vite启动项目时，预构建依赖项，并将它们缓存在node_modules/.vite/ 下, 减少了每次请求编译时间
>    - 通过esbuild将以 CommonJS 或 UMD 形式提供的依赖项转换为 ES 模块。
> 4. 配置
>    - webpack配置较为复杂，上手难度相对vite更高
>    - vite可以开箱即用，不需要过多的配置

3、vite原理

> 1. 冷启动（懒编译）： 基于原生ES模块和懒编译，实现快速冷启动。只在文件被请求的时候编译，而不是启动的时候编译所有文件；
> 2. HMR
> 3. 预构建依赖： 同上
> 4. Build： 生产环境使用Rollup作为构建工具
> 5. 支持多种前端框架

4、vite和webpack的HMR区别

> Vite：
>
> 1. 利用浏览器ES模块支持，开发过程中不需要对js文件打包或者转换，当代码发生变化了直接通过浏览器模块系统更新模块，不需要重新打包整个文件
> 2. 通过预构建和缓存策略，确保模块可以尽可能快的被加载，HMR中也可以更快的替换被修改的模块
> 3. vite的HMR侧裂尽可能少的减少重新加载模块数量；只更新实际发生变化的模块
>
> webpack：
>
> 	1. webpack开发环境使用hmr的时候需要对所有文件进行打包编译，当文件变化的时候，webpack需要重新编译被修改过的模块，然后推送给浏览器
> 	1. webpack通过websocket实现HMR
> 	1. webpack通过热模块替换插件管理HMR，该模块需要处理模块依赖更新，依赖关系解析和模块的重新加载
>
> 
>
> Vite的HMR之所以更快，是因为它直接利用了浏览器的原生模块系统，减少了打包和通信的开销。
>
> 而Webpack的HMR则需要更多的步骤来处理文件变化和模块更新。
>
> Vite的这种设计哲学使得它在开发环境中提供了更快的反馈循环，特别是在大型项目中。然而，这并不意味着Webpack的HMR不好，它仍然是一个强大的功能，可以适应各种复杂的构建场景。开发者应根据项目的具体需求和团队的技术栈来选择最合适的工具。

5、vite的预编译和懒编译

> 懒编译：
>
> - 懒编译是按需编译的策略，核心是在代码实际被执行或者请求之前不进行编译。
> - 在前段开发中，只有在开发服务器检测到特定文件变更货或者在页面被访问的时候，才会编译这些文件
> - 这种方式可以减少不必要的编译工作，提升开发效率
> - 优点： <font color="red">节省资源、快速响应、及时更新</font>
>
> 预编译：
>
> - 预编译是在项目启动之前或者构建过程中提前进行编译工作。
> - 预编译的目的是通过提前完成编译任务来优化运行时性能或者减少运行时的编译负担
> - 预编译通常用于生成生产环境的构建文件，或者在开发环境 中七天编译项目依赖和公共代码

6、预编译会处理哪些文件：

> vite预编译过程主要关注项目依赖的处理，一提高开发环境和生产环境的性能；
>
> 1. 依赖项：
>    - vite会提前编译项目中声明的依赖项，如node_modules
>    - 对于生产环境，vite会使用Rollup预设来构建库，并生成es和umd格式的构建文件。
> 2. ts文件
> 3. js文件
> 4. css、scss、；ess等
> 5. 图片资源和静态资源
> 6. 模板文件等；
>
> 预编译目的是减少开发环境中的实时编译负担，并为生产环境提供优化的构建结果。
>
> 在开发环境中，vite利用浏览器的原生es模块特性来提供快速的模块加载；
>
> 生产环境中，vite通过预编译依赖项和其他资源来生成搞笑的输出文件。

7、vite流程

> vite全流程：
>
> 使用 `vite` 时， 从 `vite` 命令启动，到最后的页面展示，需要经历的过程：
>
> 1. 使用 [esbuild](https://link.juejin.cn?target=https%3A%2F%2Fesbuild.github.io%2F) [预构建依赖](https://link.juejin.cn?target=https%3A%2F%2Fcn.vitejs.dev%2Fguide%2Fdep-pre-bundling.html)，提前将项目的第三方依赖格式化为 `ESM` 模块；
> 2. 启动一个 `node` 服务；
> 3. 打开浏览器，去访问 `index.html`；
> 4. 基于浏览器已经支持原生的 `ESM` 模块, 逐步去加载入口文件以及入口文件的依赖模块。浏览器发起请求以后，`dev server` 端会通过 `middlewares` 对请求做拦截，然后对源文件做 `resolve`、`load`、`transform`、`parse` 操作，然后再将转换以后的内容发送给浏览器。
>
> 

8、vite为什么比webpack快

> 1. 不做全量打包，按需编译
> 2. 使用了go语言编写的esbuild模块，比js编写的打包器预构建依赖快10-100倍
> 3. 按需加载，模块质检依赖关系解析由浏览器实现，vite只需要在浏览器请求源码的时候进行转换并按需提供源码。
> 4. 缓存机制；
> 5. Vite 利用 HTTP 头来加速整个页面的重新加载（再次让浏览器为我们做更多事情）：源码模块的请求会根据 `304 Not Modified` 进行协商缓存，而依赖模块请求则会通过 `Cache-Control: max-age=31536000,immutable` 进行强缓存，因此一旦被缓存它们将不需要再次请求。

9、相比webpack，vite优缺点

> 优点：
>
> 1. 冷启动
> 2. 更快的HMR
>
> 缺点：
>
> 1. 开发环境首屏加载变慢；
>
>    由于 `unbundle` 机制，`Vite` 首屏期间需要额外做其它工作。不过首屏性能差只发生在 `dev server` 启动以后第一次加载页面时发生。之后再 `reload` 页面时，首屏性能会好很多。原因是 `dev server` 会将之前已经完成转换的内容缓存起来
>
> 2. 开发环境下懒加载变慢；
>
>    跟首屏加载变慢的原因一样。`Vite` 在懒加载方面的性能也比 `Webpack` 差。由于 `unbundle` 机制，动态加载的文件，需要做 `resolve`、`load`、`transform`、`parse` 操作，并且还有大量的 `http` 请求，导致懒加载性能也受到影响。
>
> 3. webpack支持更广，生态更丰富