<!-- @format -->

### HTTP 各版本特性及区别

HTTP 是基于 TCP/IP 协议的一个**应用层**协议，是现代互联网的一个基础协议。规定了客户端与服务端之间的通信格式以及所占用的服务端口 80(HTTPS 是 443)。

### 1、版本

HTTP 协议从开始立项到现在一共经历了 4 个版本:

> HTTP 0.9 -> HTTP 1.0 -> HTTP 1.1 -> HTTP 2

---

### 2、HTTP 0.9

HTTP 0.9 是一个最古老的版本

👉 特性/缺陷：

- 只支持 GET 请求方式：由于不支持其他请求方式，因此客户端是没办法向服务端传输太多的信息
- 没有请求头概念：所以不能在请求中指定版本号，服务端也只具有返回 HTML
  服务端相响应之后，立即关闭 TCP 连接
- <font color="red">只支持GET请求，并且响应只能是HTML格式的。</font>

---

### 3、HTTP 1.0

👉 特性：

- 引入了更多的请求方法，  http 请求 api：如 POST，DELETE，PUT，HEADER
- 新增了请求头和响应头的概念，在通信中指定了 HTTP 协议版本号，以及其他的一些元信息 (比如: 状态码、权限、缓存、内容编码)
  扩充了传输内容格式，图片、音视频资源、二进制等都可以进行传输、（<font color="red">可以传输更多类型的数据</font>）

👉 缺陷：

- 无状态： 服务器不会跟踪和记录 http 请求过的状态
- 无连接： HTTP1.0 规定浏览器和服务器保持短暂的连接，浏览器的每次请求都需要与服务器建立一个 TCP 连接，服务器处理完成后立即断开 TCP 连接

- 无状态：可以通过 cookie/session 机制处理
- 无法复用连接：由于无连接的特性，导致网络请求复用率较低。
- 队头阻塞：http1.0 规定下一个请求必须在上一个请求响应之后才能发送，所以假如上一个请求一直没有响应（阻塞）就会造成队头阻塞

---

### 4、HTTP 1.1

目前最广泛使用的版本。引入了持久连接、管道机制、分块传输编码等特性。

👉 特性：

- 长连接：通过 http-header 中的 Connection：keep-alive 开启长连接，可以保证连接不断开，不必像 http1.0 一样反复建立 tcp 连接提高网络利用率 （<font color="red">减少了TCP连接的建立次数，提高了性能；支持复用连接，节省了资源；</font>）
- 管道化：基于上面长连接的基础，管道化可以不等第一个请求响应继续发送后面的请求，但响应的顺序还是按照请求的顺序返回
- 缓存处理：新增字段 cache-control，详见《http 缓存》笔记
- 断点传输：同上

xia👉 对管道化的理解:

tcp 没有断开，用的同一个通道

```
--> 请求1 > 响应1
--> 请求2 > 响应2
--> 请求3 > 响应3
```

管道化的请求响应：

```
--> 请求1 --> 请求2 --> 请求3

--> 响应1 --> 响应2 --> 响应3
```

##### 即使服务器先准备好响应 2,也是按照请求顺序先返回响应 1

虽然管道化，可以一次发送多个请求，但是响应仍是顺序返回，仍然无法解决队头阻塞的问题

👉 怎么解决解决队头阻塞的问题?

<img src="https://raw.githubusercontent.com/tengyuanOasis/image/master/image/image-20220507145054676.png" alt="image-20220507145054676" style="zoom:33%;float:left" />

> 实际上，现阶段的浏览器厂商采取了另外一种做法，它允许我们打开多个 TCP 的会话。
> 也就是说，上图我们看到的并行，其实是不同的 TCP 连接上的 HTTP 请求和响应。这也就是我们所熟悉的浏览器对同域下并行加载 6~8 个资源的限制。而这，才是真正的并行！

👉 浏览器同域名请求的最大并发数限制

> 当我们在浏览网页的时候，对浏览速度有一个重要的影响因素，就是浏览器的并发数量。并发数量简单通俗的讲就是，当浏览网页的时候同时工作的进行数量。

- HTTP 客户端一般对同一个服务器的并发连接个数都是有限制的。
  实际上，浏览器确实使用并行连接，但它们将并行连接的总数限制为少量（**通常为四个**）。服务器可以自由地关闭来自特定客户端的过多连接。

👉Http 1.1 缺陷：

- 明文传输
- 无状态: 其实还是没有解决无状态连接的
- 队头阻塞: 当有多个请求同时被挂起的时候,就会拥塞请求通道，导致后面请求无法发送
- 臃肿的消息首部: HTTP/1.1 能压缩请求内容,但是消息首部不能压缩;在现今请求中,消息首部占请求绝大部分(甚至是全部)也较为常见.

### 5、HTTP 2

先来理解几个概念：

- **帧：** HTTP/2 数据通信的最小单位消息：指 HTTP/2 中逻辑上的 HTTP 消息。例如请求和响应等，消息由一个或多个帧组成。
- **流：** 存在于连接中的一个虚拟通道。流可以承载双向消息，每个流都有一个唯一的整数 ID。
- **消息：** 与逻辑消息对应的完整的一系列数据帧。

👉 特性:

- 二进制帧封装:

  > HTTP 2 采用**二进制格式**传输数据，而非 HTTP/1.x 的文本格式，二进制协议解析起来**更高效**。
  >
  > HTTP 1.x 的解析是基于文本；
  >
  > HTTP 2 之后将所有传输的信息分割为更小的消息和帧，并对它们采用二进制格式的编码，提高传输效率

- 多路复用:

  > - 同域名下的所有通信都在单个连接中完成。
  >
  > - 单个连接可以承载任意数量的双向数据流。
  >
  > - 数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装
  >
  > - 同个域名只需要占用一个 TCP 连接，消除了因多个 TCP 连接而带来的延时和内存消耗。
  >
  >   单个连接上可以并行交错地请求和响应，之间互不干扰。
  >
  >   在 HTTP/2 中，每个请求都可以带一个 31bit 的优先值，0 表示最高优先级， 数值越大优先级越低。有了这个优先值，客户端和服务器就可以在处理不同的流时采取不同的策略，以最优的方式发送流、消息和帧。

- 头部压缩:

  > 由于 HTTP 是无状态的，每一个请求都需要头部信息标识这次请求相关信息，所以会造成传输很多重复的信息，当请求数量增大的时候，消耗的资源就会慢慢积累上去。所以 HTTP 2 可以维护一个头部信息字典，差量进行更新头信息，减少头部信息传输占用的资源，

- 服务器推送

  > 服务端可以在发送页面 HTML 时主动推送其它资源，而不用等到浏览器解析到相应位置，发起请求再响应。例如服务端可以主动把 JS 和 CSS 文件推送给客户端，而不需要客户端解析 HTML 时再发送这些请求。
  >
  > 服务端可以主动推送，客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送 RST_STREAM 帧来拒收。主动推送也遵守同源策略，服务器不会随便推送第三方资源给客户端。

本文参考:
https://juejin.im/post/6844903923136856078
https://segmentfault.com/a/1190000019891825
