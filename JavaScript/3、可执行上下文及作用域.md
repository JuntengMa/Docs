# JS作用域、执行上下文、this

##### 1、什么是执行上下文

> 当我们执行一个js函数或变量时，JavaScript会生成一个与该方法对应的**执行环境**（context），又叫做执行上下文
>
> 执行上下文决定了这些函数或变量可以访问哪些数据，以及它们的行为

##### 2、什么是执行栈

> 执行上下文中有这个方法的 私有作用域 、 上层作用域指向、参数、私有作用域中定义的变量、this对象等 ， 这个执行环境会被添加到一个栈中，这个栈就是执行栈

![image-20220214111216450](https://gitee.com/JuntengMa/imgae/raw/master/image-20220214111216450.png)

##### 3、执行上下文类型

> - 全局上下文
>   - 浏览器中，全局上下文就是我们常说的window对象、全局变量等
> - 函数上下文
>   - 函数调用都有自己的上下文，当代码执行流进入函数时，函数的上下文被推到一个上下文栈上

##### 4、作用域

> 作用域就是用来规定js执行过程中，代码可访问到的变量、函数的规则

作用域主要两类

- 词法作用域

  > 词法作用域，**函数声明时**所在的位置决定的，Js作用域为词法作用域，

- 动态作用域

  > 动态作用域是在**函数执行**的时候确认的，

##### 5、作用域链

> 上下文中的代码在执行的时候，会创建变量对象的一个作用域链，**用于决定各级上下文代码访问变量和函数时的顺序；**
>
> 代码正在执行的上下文的变量对象始终位于作用域链的最前端；
>
> 全局上下文的变量对象始终是作用域链的最后一个变量对象；

![image-20220214112806939](https://gitee.com/JuntengMa/imgae/raw/master/image-20220214112806939.png)



>以上代码涉及3个上下文：
>
>全局上下文、changeColor()的局部上下文和swapColors()的局部上下文。
>
>全局上下文中有一个变量color和一个函数changeColor()。
>
>changeColor()的局部上下文中有一个变量anotherColor和一个函数swapColors()，但在这里可以访问全局上下文中的变量color。swapColors()的局部上下文中有一个变量tempColor，只能在这个上下文中访问到。全局上下文和changeColor()的局部上下文都无法访问到tempColor。而在swapColors()中则可以访问另外两个上下文中的变量，因为它们都是父上下文，图4-3展示了前面这个例子的作用域链。

![image-20220214112859902](https://gitee.com/JuntengMa/imgae/raw/master/image-20220214112859902.png)



> 中的矩形表示不同的上下文。内部上下文可以通过作用域链访问外部上下文中的一切，但外部上下文无法访问内部上下文中的任何东西。上下文之间的连接是线性的、有序的。每个上下文都可以到上一级上下文中去搜索变量和函数，但任何上下文都不能到下一级上下文中去搜索。swapColors()局部上下文的作用域链中有3个对象：swapColors()的变量对象、changeColor()的变量对象和全局变量对象。swapColors()的局部上下文首先从自己的变量对象开始搜索变量和函数，搜不到就去搜索上一级变量对象。changeColor()上下文的作用域链中只有2个对象：它自己的变量对象和全局变量对象。因此，它不能访问swapColors()的上下文。



##### 6、This指向

this指向可以大致分类4中

> - 作为函数调用 , 指向为winodw
>
>   ```js
>   let fn = function(){
>     console.log('this.name: ', this.name);
>     console.log('this: ', this);
>   }
>   fn()  
>   //   console.log('this.name: ', this.name);       
>   //    window
>   ```
>
> - 作为Object的属性调用 ， 指向改Object本身
>
>   ```js
>   let fn = function(){
>     console.log('this.name: ', this.name);
>     console.log('this: ', this);
>   }
>   let obj = {
>     name: 'KangKang',
>     fn
>   }
>   obj.fn() 
>   //this.name:  KangKang
>   //this:  { name: 'KangKang', fn: [Function: fn] }
>   ```
>
> - [call、bind、apply 修改this指向](https://github.com/JuntengMa/FE-handwritten-questions/tree/main/This%E6%8C%87%E5%90%91)
>
>   ```js
>   let fn = function(){
>     console.log('this.name: ', this.name);
>     console.log('this: ', this);
>   }
>   let obj = {
>     name: 'KangKang',
>     fn
>   }
>   obj.fn() 
>   // this.name:  KangKang
>   // this:  { name: 'KangKang', fn: [Function: fn] }
>   ```
>
> - 构造函数使用 ， 指向构造函数实例
>
>   ```js
>   let fn = function(){
>     console.log('this.name: ', this.name);
>     console.log('this: ', this);
>   }
>   let obj = {
>     name: 'KangKang',
>     fn
>   }
>   obj.fn() 
>   // this.name:  undefined
>   // this:  fn {}
>   ```
>
>   
