### 事件循环机制

> # 1、事件循环
>
> 首先要知道，JS是单线程的 ， 且JS分为同步任务和异步任务
>
> **JS执行机制可以看做一个主线程加上一个任务队列.**
>
> 同步任务都在主线程(这里的主线程就是JS引擎线程)上执行，会形成一个`执行栈`
>
> 主线程之外，事件触发线程管理着一个`任务队列`，只要异步任务有了运行结果，就在`任务队列`之中放一个事件回调
>
> 一旦`执行栈`中的所有同步任务执行完毕(也就是JS引擎线程空闲了)，系统就会读取`任务队列`，将可运行的异步任务(任务队列中的事件回调，只要任务队列中有事件回调，就说明可以执行)添加到执行栈中，开始执行。
>
> 该过程是不断重复的,所以又叫**做事件循环**(Event loop)



> # **小结：**
>
> js执行期间，同步任务都在执行栈中执行，异步任务则被压入任务队列，当同步任务执行完成，测读取任务队列中的任务，当任务队列中有事件回调，则将其添加到执行栈中开始执行

> # 2、宏任务 & 微任务
>
> **宏任务**
>
> 我们可以将每次执行栈执行的代码当做是一个宏任务(包括每次从事件队列中获取一个事件回调并放到执行栈中执行)， 每一个宏任务会从头到尾执行完毕，不会执行其他
>
> 由于`JS引擎线程`和`GUI渲染线程`是互斥的关系，浏览器为了能够使`宏任务`和`DOM任务`有序的进行，会在一个`宏任务`执行结果后，在下一个`宏任务`执行前，`GUI渲染线程`开始工作，对页面进行渲染
>
> 宏任务 --> GUI 渲染 --> 宏任务
>
> 常见的宏任务
>
> 主代码块
>
> - setTimeout
> - setInterval
> - setImmediate ()-Node
> - requestAnimationFrame ()-浏览器
>
> **微任务**
>
> 我们已经知道`宏任务`结束后，会执行渲染，然后执行下一个`宏任务`， 而微任务可以理解成在当前`宏任务`执行后立即执行的任务
>
> 当一个`宏任务`执行完，会在渲染前，将执行期间所产生的所有`微任务`都执行完
>
> 宏任务 -> 微任务 -> GUI渲染 -> 宏任务 -> ...
>
> 常见微任务
>
> - process.nextTick ()-Node
> - Promise.then()
> - catch
> - finally
> - Object.observe
> - MutationObserver
