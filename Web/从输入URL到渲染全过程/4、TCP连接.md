##### 1、什么是TCP、IP

> TCP/ IP 是互联网相关的各类协议的总称

##### 2、TCP/IP 分层

> 应用层 —>传输层 —>网络层 —>数据链路层

##### 3、应用层作用

> 应用层决定了向用户提供应用服务时通信的活动
>
> TCP/IP 协议族内预存了各类通用的应用服务。比如，**FTP**（FileTransfer Protocol，文件传输协议）和 **DNS**（Domain Name System，域名系统）服务就是其中两类。
>
> `HTTP 协议也处于该层`

##### 4、传输层作用

> 传输层对上层应用层 ， 提供处于网络连接中的两台计算机之间的数据传输
>
> 在传输层有两个性质不同的协议：
>
> - **TCP**（Transmission ControlProtocol，传输控制协议）
>   - TCP 提供**面向连接**的服务。在传送数据之前`必须先建立连接`，数据传送结束后要释放连接。
>   - > TCP 不提供广播或多播服务。由于 <font color="red">TCP 要提供**可靠**的，面向连接的传输服务</font>（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、流量控制、拥塞控制机制，在数据传完后，还会四次挥手断开连接用来节约系统资源），这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。
>   - TCP **一般用于文件传输、发送和接收邮件、远程登录等场景**。
> - **UDP（User Data Protocol，用户数据报协议）。**
>   - **UDP 在传送数据之前不需要先建立连接**，远程主机在收到 UDP 报文后，不需要给出任何确认。
>   - 虽然 UDP **不提供可靠交付**，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等

##### 5、网络层（又名网络互连层）作用

> 网络层用来处理在网络上流动的数据包。
>
> 数据包是网络传输的最小数据单位。
>
> 该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方。
>
> IP（Internet Protocol）网际协议位于网络层

##### 6、链路层（又名数据链路层，网络接口层）

> 用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等物理可见部分（还包括连接器等一切传输媒介）。硬件上的范畴均在链路层的作用范围之内。

##### 7、TCP/IP 通信传输流

![image-20220212210823593](https://raw.githubusercontent.com/JuntengMa/image/master/image/image-20220212210823593.png)

##### 8、==TCP三次握手==

![image-20220212211759313](https://raw.githubusercontent.com/JuntengMa/image/master/image/image-20220212211759313.png)

> 为了准确无误地将数据送达目标处，TCP 协议采用了三次握手（three-way handshaking）策略。
>
> 用 TCP 协议把数据包送出去后，TCP不会对传送后的情况置之不理，它一定会向对方确认是否成功送达。
>
> 握手过程中使用了 TCP 的标志（flag） —— SYN（synchronize）和ACK（acknowledgement）。
>
> 1、发送端首先发送一个带 SYN 标志的数据包给对方。
>
> 2、接收端收到后，回传一个带有 SYN/ACK 标志的数据包以示传达确认信息。
>
> 3、最后，发送端再回传一个带 ACK 标志的数据包，代表“握手”结束。
>
> 若在握手过程中某个阶段莫名中断，TCP 协议会再次以相同的顺序发送相同的数据包。

##### 9、==为什么是三次握手而不是四次或者两次==

> 第三次握手除了让服务端知道，服务端发送能力和客户端的接收能力正常之外，
>
> **还可以防止数据报延迟带来的不必要的资源消耗**：
>
> 1. 当客户端发起tcp第一次握手的请求时，因为网络问题滞留在网络中，这时候<u>客户端因为等待太久没有响应所以自动重发了握手请求</u>并完成了所有数据请求关闭了与服务端的链接
> 2. 这时候服务端才接收到第一次滞留在网络中的握手请求，服务端会向客户端发送第二次握手并处于等待第3次握手状态，客户端接收到第二次握手请求后发现是过期的请求就可以通过停止发送第三次握手，服务端一段时间没接到第三次握手请求会自动关闭请求监听。
> 3. 握手次数两次或四次都有问题，四次浪费资源，两次又不能保证因数据延迟的损耗

![image-20220217150301454](https://raw.githubusercontent.com/JuntengMa/image/master/202202171503538.png)

##### 10、==四次挥手==

① 四次挥手过程详解

建立一个 TCP 连接需要三次握手，而终止一个 TCP 连接要经过四次挥手（也有将四次挥手叫做四次握手的）。这是由于 TCP 的**半关闭**

（half-close）特性造成的，TCP 提供了连接的一端，在结束它的发送后还能接收来自另一端数据的能力。

TCP 连接的释放需要发送四个包（执行四个步骤），因此称为四次挥手(`Four-way handshake`)，**客户端或服务端均可主动发起挥手动作**。

![image-20220217155856745](https://raw.githubusercontent.com/JuntengMa/image/master/202202171558813.png)

回顾一下上图中符号的意思：

- `FIN` ：连接终止位
- `seq`：发送的第一个字节的序号
- `ACK`：确认报文段
- `ack`：确认号。希望收到的下一个数据的第一个字节的序号

**1）第一次挥手**：客户端发送一个 FIN 报文（请求连接终止：FIN = 1），报文中会指定一个序列号 seq = u。并**停止再发送数据，主动关闭 TCP 连接**。此时客户端处于 `FIN_WAIT1` 状态，等待服务端的确认。

> `FIN-WAIT-1` - 等待远程TCP的连接中断请求，或先前的连接中断请求的确认；

**2）第二次挥手**：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 `CLOSE_WAIT` 状态。

> `CLOSE-WAIT` - 等待从本地用户发来的连接中断请求；

**此时的 TCP 处于半关闭状态，客户端到服务端的连接释放**。客户端收到服务端的确认后，进入`FIN_WAIT2`（终止等待 2）状态，等待服务端发出的连接释放报文段。

> `FIN-WAIT-2` - 从远程TCP等待连接中断请求；

**3）第三次挥手**：如果服务端也想断开连接了（没有要向客户端发出的数据），和客户端的第一次挥手一样，发送 FIN 报文，且指定一个序列号。此时服务端处于 `LAST_ACK` 的状态，等待客户端的确认。

> `LAST-ACK` - 等待原来发向远程TCP的连接中断请求的确认；

**4）第四次挥手**：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答（ack = w+1），且把服务端的序列值 +1 作为自己 ACK 报文的序号值（seq=u+1），此时客户端处于 **`TIME_WAIT` （时间等待）状态**。

11、参考资料
https://www.sohu.com/a/434706678_100004247

https://segmentfault.com/a/1190000039165592