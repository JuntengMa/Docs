1、js数据类型
基本（栈），引用（堆）
类型标识：
Number 1、浮点 010、String 100、Boolean 110、Object 000、null 所有机器码均为0、undefined  −2^30 整数来表示

2、深浅拷贝区别和实现方式

3、判断数组的方法
typeof 和 instanceOf 的区别；
Array.isArray(arr)，Object.prototype.toString.call(arr)

4、vue父子组件怎么相互传值、调用彼此的方法

5、websocket常用方法、避免断开连接和多次连接的方法

6、cookie,sessionStorage,localStorage
localStorage是永久存储在本地，生命周期是永久的，除非你主动去删除;
sessionStorage是存储到当前页面关闭为止，生命周期是在仅在当前会话下有效;
cookie则根据你设置的有效时间来存储，限制大小为4kb;(设置cookie：document.cookie="username=John Doe; expires=Thu, 18 Dec 2043 12:00:00 GMT";)
localStorage和sessionStorage的存储数据大小一般都是：5MB;
拓展：
Cookie 的本职工作并非本地存储，而是“维持状态”（背景：HTTP 协议是一个无状态协议，请求的时候，如何让服务器知道“我是我”呢）

7、数组降维，es6数组方法

8、vue数据更新、视图没关系的解决方案

9、react高阶组件

10、reack hook

11、vue双向绑定，v-cloak

12、promise

13、闭包的好处和坏处，防抖节流及应用场景
防抖：事件一触发就开始计时，计时范围内就算事件再次触发也不会响应，计时停止才触发响应函数（scroll）
防抖：事件一触发就开始计时，计时范围内 如果事件再次触发就会重新计时，计时停止才触发响应函数（input change）

14、单页面应用的缺点
单页面跳转仅刷新局部资源，公共资源仅刷新一次，之后的操作交互，数据交互是通过路由、ajax来进行的，页面本身没有进行刷新。
优点：
①前后端分离
②良好的交互体验——用户不用刷新页面，页面显示流畅
③减轻服务器压力——服务器只出数据
缺点：
①seo难度高——数据渲染在前端进行
②前进后退管理——单页面不能使用浏览器的前进后退
③初次加载耗时长

15、项目打包工具、webpack打包优化
对于babel-loader可以，loader: 'babel-loader?cacheDirectory=true'；
node_modules：用 DllPlugin 打包 node_modules，这个插件会把第三方库单独打包到一个文件中，这个文件就是一个单纯的依赖库。这个依赖库不会跟着你的业务代码一起被重新打包，只有当依赖自身发生版本变化时才会重新打包。
js：UglifyJsPlugin 
还可以用 Happypack——将 loader 由单进程转为多进程

16、var和let

17、对vue框架的看法，vuex的理解
vuex规定所有state里数据必须通过mutation方法来修改

18、vue刷新页面会导致，vuex中的state丢失
因为store里的数据是保存在运行内存中的,当页面刷新时，页面会重新加载vue实例，store里面的数据就会被重新赋值；
解决思路：在点击页面刷新时先将state数据保存到sessionStorage,然后才真正刷新页面
//在页面刷新时将vuex里的信息保存到sessionStorage里
window.addEventListener("beforeunload",()=>{
    sessionStorage.setItem("store",JSON.stringify(this.$store.state))
})

19、图片的处理
1、JPEG/JPG
关键字：有损压缩、体积小、加载快、不支持透明
JPG 适用于复杂的、色彩层次丰富的图片，在我们日常开发中，JPG 图片经常作为大的背景图、轮播图或 Banner 图出现。
2、PNG-8 与 PNG-24
关键字：无损压缩、质量高、体积大、支持透明
PNG 适用于颜色简单且对比强烈的图片，如logo
3、SVG
关键字：文本文件、体积小、不失真、兼容性好、图片可无限放大而不失真