# <center>JS工程化优化</center>
## 代码分割
#### 技术方案
* react-loadable
* react.lazy

#### 选型
react-loadable使用起来方便好用，
react.lazy需要配合Suspend使用，比较麻烦

#### 遇到的问题
````
最终版本：
const loadAb = (modulePath) => () =>  {
  if (__isBrowser__) {
    return  Loadable({
      loader: () => import(/* webpackChunkName: "[request]" */  `@/page/${modulePath}`),
      loading: () => {
        return null
      },
    });
  } else {
    return require(`@/page/${modulePath}`).default;
  }
}
````

此处注意：
1、前端代码编译时，import 和require 不能直接写一个变量，会导致不能正常加载。（通过查看编译后的文件位置，可看到具体问题）
    解决： 通过用字符串拼接的方式来让其正常编译
2、编译以后的文件如何能够自定义命名， 通过import后注释来保证文件名命名， request就是传入的参数值

## 公共库单独打包
* 使用external
使用external来将一些公共库单独打包出来。
例如：将react 和react-dom单独打包
````
module.exports = {
	'react': 'React',
	'react-dom': 'ReactDOM',
};
````
* 使用SplitChunksv
[webpack 4 Code Splitting 的 splitChunks 配置探索](https://imweb.io/topic/5b66dd601402769b60847149)

## 参考文档：
[webpack import() 动态加载模块踩坑](https://segmentfault.com/a/1190000015648036)
[webpack中动态import()打包后的文件名称定义](https://blog.csdn.net/javao_0/article/details/85162458)